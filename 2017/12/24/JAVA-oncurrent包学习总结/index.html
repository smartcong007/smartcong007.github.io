<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="smartcong007" />



<meta name="description" content="concurrent包是java中专门用来处理并发的包，并发编程的基础便是对这个包下的常用api的熟练使用。由于并发场景的复杂和多样性，常常会有很多不同的并发手段。此文对常见的并发api进行梳理。">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA oncurrent包学习总结">
<meta property="og:url" content="http://yoursite.com/2017/12/24/JAVA-oncurrent包学习总结/index.html">
<meta property="og:site_name" content="smartcong007">
<meta property="og:description" content="concurrent包是java中专门用来处理并发的包，并发编程的基础便是对这个包下的常用api的熟练使用。由于并发场景的复杂和多样性，常常会有很多不同的并发手段。此文对常见的并发api进行梳理。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://incdn1.b0.upaiyun.com/2017/09/0c0a50b428245a5dfb6c4250ba010fe0.png">
<meta property="og:image" content="http://incdn1.b0.upaiyun.com/2017/09/a87d1272cf9d2e199a8c2522747a0651.png">
<meta property="og:image" content="http://incdn1.b0.upaiyun.com/2017/09/411d4e8c8ae237bdd6fc22469d1c1880.png">
<meta property="og:image" content="http://incdn1.b0.upaiyun.com/2017/09/6f5e15d2343bffb3f75201a5ad812208.png">
<meta property="og:updated_time" content="2018-01-13T08:28:25.386Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JAVA oncurrent包学习总结">
<meta name="twitter:description" content="concurrent包是java中专门用来处理并发的包，并发编程的基础便是对这个包下的常用api的熟练使用。由于并发场景的复杂和多样性，常常会有很多不同的并发手段。此文对常见的并发api进行梳理。">
<meta name="twitter:image" content="http://incdn1.b0.upaiyun.com/2017/09/0c0a50b428245a5dfb6c4250ba010fe0.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="smartcong007" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>JAVA oncurrent包学习总结 | smartcong007</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>



    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5a3f5dab49b144d6"></script>




</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/paprika.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">smartcong007</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:cong99299618@hotmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/smartcong007" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 网易云音乐" href="http://music.163.com/#/user/home?id=104362235" title="网易云音乐"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">服务端大搞，架构中搞，前端小搞</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">smartcong007</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/paprika.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">smartcong007</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:cong99299618@hotmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/smartcong007" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="http://music.163.com/#/user/home?id=104362235" title="网易云音乐"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-JAVA-oncurrent包学习总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/24/JAVA-oncurrent包学习总结/" class="article-date">
      <time datetime="2017-12-24T09:26:03.000Z" itemprop="datePublished">2017-12-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JAVA oncurrent包学习总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>concurrent包是java中专门用来处理并发的包，并发编程的基础便是对这个包下的常用api的熟练使用。由于并发场景的复杂和多样性，常常会有<br>  很多不同的并发手段。此文对常见的并发api进行梳理。</p>
</blockquote>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>java中有阻塞队列的各种不同实现，都是实现自BlockingQueue接口，包含：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<p>BlockingQueue接口中有一组通用的方法对比如下，一般使用频率最高的是阻塞方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(o)</td>
<td>offer(o)</td>
<td>put(o)</td>
<td>offer(o,timeout,timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove(o)</td>
<td>poll(o)</td>
<td>take(o)</td>
<td>poll(timeout,timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>element(o)</td>
<td>peek(o) </td>
</tr>
</tbody>
</table>
<p>四组不同的行为方式解释：</p>
<p><strong>抛异常</strong>：如果试图的操作无法立即执行，抛一个异常。</p>
<p><strong>特定值</strong>：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</p>
<p><strong>阻塞</strong>：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</p>
<p><strong>超时</strong>：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>数组阻塞队列是一个有界的阻塞队列，内部实现是将对象放到一个数组中。它有一个同一时间能存储元素数量的上限。其内部对元素采用FIFO的顺序存储元素，即队列头部放置的是放入时间最久的元素，底部放置最新放入的元素。<br>简单实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue queue = new ArrayBlockingQueue(1024);  </span><br><span class="line">queue.put(&quot;1&quot;);  </span><br><span class="line">Object object = queue.take();</span><br></pre></td></tr></table></figure>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>延迟队列中的元素都有一个特定的延迟时间来确定其过期时间，如果未到达其过期时间对该元素调用take()将阻塞，到达过期时间后调用take()才能移除元素。阻塞队列中的元素都要实现Delayed接口。具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class Item&lt;T&gt; implements Delayed &#123;</span><br><span class="line">	</span><br><span class="line">	    private static final long NANO_ORIGIN = System.nanoTime();</span><br><span class="line">	</span><br><span class="line">	    private static final AtomicLong sequencer = new AtomicLong(0);</span><br><span class="line">	</span><br><span class="line">	    private final long sequenceNumber;</span><br><span class="line">	</span><br><span class="line">	    private final long time;</span><br><span class="line">	</span><br><span class="line">	    private final T content;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	    public Item(T content,long timeout)&#123;</span><br><span class="line">	</span><br><span class="line">	        this.content = content;</span><br><span class="line">	        this.time = now()+timeout;</span><br><span class="line">	        this.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">	</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    final static long now()&#123;</span><br><span class="line">	        return System.nanoTime() - NANO_ORIGIN;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	    @Override</span><br><span class="line">	    public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">	</span><br><span class="line">	        long d = unit.convert(time-now(),TimeUnit.NANOSECONDS);</span><br><span class="line">	        return d;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    @Override</span><br><span class="line">	    public int compareTo(Delayed o) &#123;</span><br><span class="line">	</span><br><span class="line">	        if (o == this)&#123;</span><br><span class="line">	            return 0;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        if(o instanceof Item)&#123;</span><br><span class="line">	            Item i = (Item) o;</span><br><span class="line">	            long con = time-i.time;</span><br><span class="line">	            if (con&lt;0) return -1;</span><br><span class="line">	            else if(con&gt;0) return 1;</span><br><span class="line">	            else if(sequenceNumber&lt;i.sequenceNumber) return -1;</span><br><span class="line">	            else return 1;</span><br><span class="line">	</span><br><span class="line">	        &#125;</span><br><span class="line">	        long d = (getDelay(TimeUnit.NANOSECONDS)-o.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">	        return d==0?0:((d &lt; 0) ? -1 : 1);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    public T getContent() &#123;</span><br><span class="line">	        return content;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">		 </span><br><span class="line">	ConcurrentTest.class:</span><br><span class="line">	</span><br><span class="line">	package com.cong.test;</span><br><span class="line">	</span><br><span class="line">	import java.util.concurrent.DelayQueue;</span><br><span class="line">	import java.util.concurrent.TimeUnit;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * Created by zhengcong on 2017/9/13.</span><br><span class="line">	 */</span><br><span class="line">	public class ConcurrentTest &#123;</span><br><span class="line">	</span><br><span class="line">	    private static DelayQueue&lt;Item&lt;String&gt;&gt; delayQueue = new DelayQueue&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	</span><br><span class="line">	        delayQueue.add(new Item(&quot;zheng&quot;, TimeUnit.NANOSECONDS.convert(6, TimeUnit.SECONDS)));</span><br><span class="line">	        Item&lt;String&gt; item;</span><br><span class="line">	        item = delayQueue.take();</span><br><span class="line">	        if (item != null) &#123;</span><br><span class="line">	            System.out.println(item.getContent());</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>内部以链式结构存储元素，如不指定上限，将以Integer.MAX_VALUE作为上限，采用FIFO的方式存储元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; unbounded = new LinkedBlockingQueue&lt;String&gt;();  </span><br><span class="line">BlockingQueue&lt;String&gt; bounded   = new LinkedBlockingQueue&lt;String&gt;(1024);  </span><br><span class="line">bounded.put(&quot;Value&quot;);  </span><br><span class="line">String value = bounded.take();</span><br></pre></td></tr></table></figure></p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>优先阻塞队列，队列中的元素必须实现java.lang.Comparable接口，由元素具体的compare()的具体实现决定了元素在队列中的存储顺序。注意：如果用Iterator对其进行枚举并不能保证它对元素的遍历是以优先级为序的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class TestPriorityQueue &#123;  </span><br><span class="line">	   </span><br><span class="line">	    static Random r=new Random(47);  </span><br><span class="line">	      </span><br><span class="line">	    public static void main(String args[]) throws InterruptedException&#123;  </span><br><span class="line">	        final PriorityBlockingQueue q=new PriorityBlockingQueue();  </span><br><span class="line">	        ExecutorService se=Executors.newCachedThreadPool();  </span><br><span class="line">	        //execute producer  </span><br><span class="line">	        se.execute(new Runnable()&#123;  </span><br><span class="line">	            public void run() &#123;  </span><br><span class="line">	                int i=0;  </span><br><span class="line">	                while(true)&#123;  </span><br><span class="line">	                    q.put(new PriorityEntity(r.nextInt(10),i++));  </span><br><span class="line">	                    try &#123;  igitggggd</span><br><span class="line">	                        TimeUnit.MILLISECONDS.sleep(r.nextInt(1000));  </span><br><span class="line">	                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	                        // TODO Auto-generated catch block  </span><br><span class="line">	                        e.printStackTrace();  </span><br><span class="line">	                    &#125;  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;); </span><br><span class="line">	          </span><br><span class="line">	        //execute consumer  </span><br><span class="line">	        se.execute(new Runnable()&#123;  </span><br><span class="line">	            public void run() &#123;  </span><br><span class="line">	                while(true)&#123;  </span><br><span class="line">	                    try &#123;  </span><br><span class="line">	                        System.out.println(&quot;take-- &quot;+q.take()+&quot; left:-- [&quot;+q.toString()+&quot;]&quot;);  </span><br><span class="line">	                        try &#123;  </span><br><span class="line">	                            TimeUnit.MILLISECONDS.sleep(r.nextInt(1000));  </span><br><span class="line">	                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	                            // TODO Auto-generated catch block  </span><br><span class="line">	                            e.printStackTrace();  </span><br><span class="line">	                        &#125;  </span><br><span class="line">	                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	                        e.printStackTrace();  </span><br><span class="line">	                    &#125;  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;);  </span><br><span class="line">	        try &#123;  </span><br><span class="line">	            TimeUnit.SECONDS.sleep(5);  </span><br><span class="line">	        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	            // TODO Auto-generated catch block  </span><br><span class="line">	            e.printStackTrace();  </span><br><span class="line">	        &#125;  </span><br><span class="line">	        System.out.println(&quot;shutdown&quot;);  </span><br><span class="line">	    &#125;  </span><br><span class="line">	 </span><br><span class="line">	&#125;  </span><br><span class="line">	 </span><br><span class="line">	class PriorityEntity implements Comparable&lt;PriorityEntity&gt; &#123;  </span><br><span class="line">	    private static int count=0;  </span><br><span class="line">	    private int id=count++;  </span><br><span class="line">	    private int priority;  </span><br><span class="line">	    private int index=0;  </span><br><span class="line">	 </span><br><span class="line">	    public PriorityEntity(int _priority,int _index) &#123;  </span><br><span class="line">	        this.priority = _priority;  </span><br><span class="line">	        this.index=_index;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	      </span><br><span class="line">	    public String toString()&#123;  </span><br><span class="line">	        return id+&quot;# [index=&quot;+index+&quot; priority=&quot;+priority+&quot;]&quot;;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	 </span><br><span class="line">	    //数字小，优先级高  </span><br><span class="line">	    public int compareTo(PriorityEntity o) &#123;  </span><br><span class="line">	        return this.priority &gt; o.priority ? 1 </span><br><span class="line">	                : this.priority &lt; o.priority ? -1 : 0;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	 </span><br><span class="line">	    //数字大，优先级高  </span><br><span class="line">	//  public int compareTo(PriorityTask o) &#123;  </span><br><span class="line">	//      return this.priority &lt; o.priority ? 1  </span><br><span class="line">	//              : this.priority &gt; o.priority ? -1 : 0;  </span><br><span class="line">	//  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>实质上就是仅有一个元素的阻塞队列</p>
<h2 id="双端阻塞队列-BlockingDeque"><a href="#双端阻塞队列-BlockingDeque" class="headerlink" title="双端阻塞队列(BlockingDeque)"></a>双端阻塞队列(BlockingDeque)</h2><p>与阻塞队列的区别是它的两端都可以添加或取出元素</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>addFirst(o)</td>
<td>offerFirst(o)</td>
<td>putFirst(o)</td>
<td>offerFirst(o,timeout,timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>removeFirst(o)</td>
<td>pollFirst(o)</td>
<td>takeFirst(o)</td>
<td>pollFirst(o,timeout,timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>getFirst(o)</td>
<td>peekFirst(o)</td>
</tr>
</tbody>
</table>
<p>具体操作与普通阻塞队列一样</p>
<h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><p><strong>ConcurrentHashMap</strong>:常用，介绍略</p>
<p><strong>ConcurrentNavigableMap</strong>：该并发集合能保证它生成的子集合也是并发安全的，常见的生成子map的方法如下:</p>
<h4 id="headMap"><a href="#headMap" class="headerlink" title="headMap()"></a>headMap()</h4><p>headMap(T toKey) 方法返回一个包含了小于给定 toKey 的 key 的子 map。如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素</p>
<h4 id="tailMap"><a href="#tailMap" class="headerlink" title="tailMap()"></a>tailMap()</h4><p>tailMap(T fromKey) 方法返回一个包含了不小于给定 fromKey 的 key 的子 map。<br>如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素</p>
<h4 id="subMap"><a href="#subMap" class="headerlink" title="subMap()"></a>subMap()</h4><p>subMap() 方法返回原始 map 中，键介于 from(包含) 和 to (不包含) 之间的子 map。</p>
<h2 id="常见并发工具"><a href="#常见并发工具" class="headerlink" title="常见并发工具"></a>常见并发工具</h2><h3 id="CountDownLatch（闭锁）"><a href="#CountDownLatch（闭锁）" class="headerlink" title="CountDownLatch（闭锁）"></a>CountDownLatch（闭锁）</h3><p>CountDownLatch 以一个给定的数量初始化。countDown() 每被调用一次，这一数量就减一。通过调用 await() 方法之一，线程可以阻塞等待这一数量到达零。这样可以实现让一个或多个线程等待一系列指定操作的完成后再继续往下执行。以下是一个简单示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch latch = new CountDownLatch(3);  </span><br><span class="line">Waiter      waiter      = new Waiter(latch);  </span><br><span class="line">Decrementer decrementer = new Decrementer(latch);  </span><br><span class="line">new Thread(waiter)     .start();  </span><br><span class="line">new Thread(decrementer).start();  </span><br><span class="line">Thread.sleep(4000);  </span><br><span class="line">public class Waiter implements Runnable&#123;  </span><br><span class="line">    CountDownLatch latch = null;  </span><br><span class="line">    public Waiter(CountDownLatch latch) &#123;  </span><br><span class="line">        this.latch = latch;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            latch.await();   //阻塞等待直到lauch为0</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(&quot;Waiter Released&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">public class Decrementer implements Runnable &#123;  </span><br><span class="line">    CountDownLatch latch = null;  </span><br><span class="line">    public Decrementer(CountDownLatch latch) &#123;  </span><br><span class="line">        this.latch = latch;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            this.latch.countDown();  //执行完特定操作就对latch实行减一操作 </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            this.latch.countDown();  </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            this.latch.countDown();  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier（栅栏）"><a href="#CyclicBarrier（栅栏）" class="headerlink" title="CyclicBarrier（栅栏）"></a>CyclicBarrier（栅栏）</h3><p><img src="http://incdn1.b0.upaiyun.com/2017/09/0c0a50b428245a5dfb6c4250ba010fe0.png" alt=""><br>栅栏能够确保多个线程只有都到达指定状态才能继续往下执行，构造栅栏的方法：CyclicBarrier(int count,Runnable runnable）,count指定等待栅栏的线程数量, runnable指定最后等待栅栏的线程到达后要执行的线程实例。</p>
<p>满足以下任何条件都可以让等待 CyclicBarrier 的线程释放：</p>
<ul>
<li>最后一个线程也到达 CyclicBarrier(调用 await())</li>
<li>当前线程被其他线程打断(其他线程调用了这个线程的 interrupt() 方法)</li>
<li>其他等待栅栏的线程被打断</li>
<li>其他等待栅栏的线程因超时而被释放</li>
<li>外部线程调用了栅栏的 CyclicBarrier.reset() 方法</li>
</ul>
<p>代码示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Runnable barrier1Action = new Runnable() &#123;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        System.out.println(&quot;BarrierAction 1 executed &quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">Runnable barrier2Action = new Runnable() &#123;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        System.out.println(&quot;BarrierAction 2 executed &quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">CyclicBarrier barrier1 = new CyclicBarrier(2, barrier1Action);  </span><br><span class="line">CyclicBarrier barrier2 = new CyclicBarrier(2, barrier2Action);  </span><br><span class="line">CyclicBarrierRunnable barrierRunnable1 =  </span><br><span class="line">        new CyclicBarrierRunnable(barrier1, barrier2);  </span><br><span class="line">CyclicBarrierRunnable barrierRunnable2 =  </span><br><span class="line">        new CyclicBarrierRunnable(barrier1, barrier2);  </span><br><span class="line">new Thread(barrierRunnable1).start();  </span><br><span class="line">new Thread(barrierRunnable2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CyclicBarrierRunnable implements Runnable&#123;  </span><br><span class="line">    CyclicBarrier barrier1 = null;  </span><br><span class="line">    CyclicBarrier barrier2 = null;  </span><br><span class="line">    public CyclicBarrierRunnable(  </span><br><span class="line">            CyclicBarrier barrier1,  </span><br><span class="line">            CyclicBarrier barrier2) &#123;  </span><br><span class="line">        this.barrier1 = barrier1;  </span><br><span class="line">        this.barrier2 = barrier2;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() +  </span><br><span class="line">                                &quot; waiting at barrier 1&quot;);  </span><br><span class="line">            this.barrier1.await();  //线程通过调用栅栏的await方法表示自己已经达到栅栏</span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() +  </span><br><span class="line">                                &quot; waiting at barrier 2&quot;);  </span><br><span class="line">            this.barrier2.await();  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() +  </span><br><span class="line">                                &quot; done!&quot;);  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (BrokenBarrierException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Exchanger-交换机"><a href="#Exchanger-交换机" class="headerlink" title="Exchanger(交换机)"></a>Exchanger(交换机)</h3><p><img src="http://incdn1.b0.upaiyun.com/2017/09/a87d1272cf9d2e199a8c2522747a0651.png" alt=""><br>两个线程通过一个 Exchanger 交换对象。<br>交换对象的动作由 Exchanger 的两个 exchange() 方法的其中一个完成。<br>代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Exchanger exchanger = new Exchanger();  //一个exchanger只能和两个线程关联</span><br><span class="line">ExchangerRunnable exchangerRunnable1 =  </span><br><span class="line">        new ExchangerRunnable(exchanger, &quot;A&quot;);  </span><br><span class="line">ExchangerRunnable exchangerRunnable2 =  </span><br><span class="line">        new ExchangerRunnable(exchanger, &quot;B&quot;);  </span><br><span class="line">new Thread(exchangerRunnable1).start();  </span><br><span class="line">new Thread(exchangerRunnable2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ExchangerRunnable implements Runnable&#123;  </span><br><span class="line">    Exchanger exchanger = null;  </span><br><span class="line">    Object    object    = null;  </span><br><span class="line">    public ExchangerRunnable(Exchanger exchanger, Object object) &#123;  </span><br><span class="line">        this.exchanger = exchanger;  </span><br><span class="line">        this.object = object;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Object previous = this.object;  </span><br><span class="line">            this.object = this.exchanger.exchange(this.object);  </span><br><span class="line">            System.out.println(  </span><br><span class="line">                    Thread.currentThread().getName() +  </span><br><span class="line">                    &quot; exchanged &quot; + previous + &quot; for &quot; + this.object  </span><br><span class="line">            );  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h3><p>java.util.concurrent.Semaphore 类是一个计数信号量。这就意味着它具备两个主要方法：</p>
<ul>
<li>acquire()</li>
<li>release()</li>
</ul>
<p>计数信号量由一个指定数量的 “许可” 初始化。每调用一次 acquire()，一个许可会被调用线程取走。每调用一次 release()，一个许可会被返还给信号量。因此，在没有任何 release() 调用时，最多有 N 个线程能够通过 acquire() 方法，N 是该信号量初始化时的许可的指定数量。这些许可只是一个简单的计数器。这里没啥奇特的地方</p>
<p><strong>Semaphore 用法</strong><br>信号量主要有两种用途：</p>
<ol>
<li>保护一个重要(代码)部分防止一次超过 N 个线程进入。</li>
<li>在两个线程之间发送信号。</li>
</ol>
<p>示例代码如下，该代码具有上述1对应的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreTest &#123;</span><br><span class="line">	 </span><br><span class="line">	    private static int count=0;</span><br><span class="line">	 </span><br><span class="line">	    private static Semaphore semaphore = new Semaphore(4);</span><br><span class="line">	 </span><br><span class="line">	    public static void method() throws InterruptedException &#123;</span><br><span class="line">	 </span><br><span class="line">	        semaphore.acquire();</span><br><span class="line">	        System.out.println(String.format(&quot;当前已经有%d个线程进入该方法&quot;,++count));</span><br><span class="line">	        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">	        semaphore.release();</span><br><span class="line">	        count--;</span><br><span class="line">	 </span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">	 </span><br><span class="line">	        Runnable runnable = new Runnable() &#123;</span><br><span class="line">	            @Override</span><br><span class="line">	            public void run() &#123;</span><br><span class="line">	                try &#123;</span><br><span class="line">	                    method();</span><br><span class="line">	                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">	                    e.printStackTrace();</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;;</span><br><span class="line">	 </span><br><span class="line">	        Thread thread1 = new Thread(runnable,&quot;Thread-1&quot;);</span><br><span class="line">	        Thread thread2 = new Thread(runnable,&quot;Thread-2&quot;);</span><br><span class="line">	        Thread thread3 = new Thread(runnable,&quot;Thread-3&quot;);</span><br><span class="line">	        Thread thread4 = new Thread(runnable,&quot;Thread-4&quot;);</span><br><span class="line">	        Thread thread5 = new Thread(runnable,&quot;Thread-5&quot;);</span><br><span class="line">	        Thread thread6 = new Thread(runnable,&quot;Thread-6&quot;);</span><br><span class="line">	        Thread thread7 = new Thread(runnable,&quot;Thread-7&quot;);</span><br><span class="line">	        Thread thread8 = new Thread(runnable,&quot;Thread-8&quot;);</span><br><span class="line">	 </span><br><span class="line">	        thread1.start();</span><br><span class="line">	        thread2.start();</span><br><span class="line">	        thread3.start();</span><br><span class="line">	        thread4.start();</span><br><span class="line">	        thread5.start();</span><br><span class="line">	        thread6.start();</span><br><span class="line">	        thread7.start();</span><br><span class="line">	        thread8.start();</span><br><span class="line">	 </span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>在线程之间发送信号</strong><br>如果你将一个信号量用于在两个线程之间传送信号，通常你应该用一个线程调用 acquire() 方法，而另一个线程调用 release() 方法。如果没有可用的许可，acquire() 调用将会阻塞，直到一个许可被另一个线程释放出来。同理，如果无法往信号量释放更多许可时，一个 release() 调用也会阻塞。</p>
<p>通过这个可以对多个线程进行协调。比如，如果线程 1 将一个对象插入到了一个共享列表(list)之后之后调用了 acquire()，而线程 2 则在从该列表中获取一个对象之前调用了 release()，这时你其实已经创建了一个阻塞队列。信号量中可用的许可的数量也就等同于该阻塞队列能够持有的元素个数。比较简单，不用演示。。。</p>
<p><strong>公平</strong><br>没有办法保证线程能够公平地可从信号量中获得许可。也就是说，无法担保掉第一个调用 acquire() 的线程会是第一个获得一个许可的线程。如果第一个线程在等待一个许可时发生阻塞，而第二个线程前来索要一个许可的时候刚好有一个许可被释放出来，那么它就可能会在第一个线程之前获得许可。如果你想要强制公平，Semaphore 类有一个具有一个布尔类型的参数的构造子，通过这个参数以告知 Semaphore 是否要强制公平。强制公平会影响到并发性能，所以除非你确实需要它否则不要启用它。<br>以下是如何在公平模式创建一个 Semaphore 的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = new Semaphore(1, true);</span><br></pre></td></tr></table></figure></p>
<h3 id="ExecutorService-执行器服务"><a href="#ExecutorService-执行器服务" class="headerlink" title="ExecutorService(执行器服务)"></a>ExecutorService(执行器服务)</h3><p>java.util.concurrent.ExecutorService 接口表示一个异步执行机制，使我们能够在后台执行任务。因此一个 ExecutorService 很类似于一个线程池。实际上，存在于 java.util.concurrent 包里的 ExecutorService 实现就是一个线程池实现。</p>
<p>创建ExecutorService的两种方式：</p>
<ul>
<li><p>调用Executors类的工厂方法：</p>
<ol>
<li>Executors.newCachedThreadPool();</li>
<li>Executors.newFixedThreadPool();</li>
<li>Executors.newScheduledThreadPool();</li>
<li>Executors.newSingleThreadExecutor();</li>
<li>Executors.newSingleThreadScheduledExecutor()</li>
<li>Executors.newWorkStealingPool();</li>
</ol>
</li>
<li><p>直接利用ExecutorService的实现类ThreadPoolExecutor初始化出一个ExecutorService的实例：<br>ThreadPoolExecutor 包含的线程池能够包含不同数量的线程。池中线程的数量由以下变量决定：</p>
<ul>
<li>corePoolSize</li>
<li>maximumPoolSize</li>
</ul>
<p>当一个任务委托给线程池时，如果池中线程数量低于 corePoolSize，一个新的线程将被创建，即使池中可能尚有空闲线程。如果内部任务队列已满，而且有至少 corePoolSize 正在运行，但是运行线程的数量低于 maximumPoolSize，一个新的线程将被创建去执行该任务。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolServiceImpl implements ThreadPoolService &#123;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(ThreadPoolServiceImpl.class);</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 主线程数</span><br><span class="line">     */</span><br><span class="line">    private int corePoolSize = 20;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 最大线程数</span><br><span class="line">     */</span><br><span class="line">    private int maximumPoolSize = 150;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 线程池维护线程所允许的空闲时间</span><br><span class="line">     */</span><br><span class="line">    private long keepAliveTime = 60;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 单例的线程池类</span><br><span class="line">     */</span><br><span class="line">    private ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line">    </span><br><span class="line">    private ScheduledExecutorService scheduledExecutorService;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 线程池所使用的缓冲队列的大小</span><br><span class="line">     */</span><br><span class="line">    private int queueSize = 100;</span><br><span class="line">    private boolean inited = false;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 当线程池满时，是否阻塞住</span><br><span class="line">     */</span><br><span class="line">    private boolean blockWhenFull = true;</span><br><span class="line"> </span><br><span class="line">    public void init() &#123;</span><br><span class="line">        if(inited) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.threadPoolExecutor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;Runnable&gt;(queueSize), new BlockingQueuePut());</span><br><span class="line">        this.threadPoolExecutor.allowCoreThreadTimeOut(true);</span><br><span class="line">        inited = true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Future&lt;?&gt; addTask(Runnable task) &#123;</span><br><span class="line">        if(!inited) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        return threadPoolExecutor.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setCorePoolSize(int corePoolSize) &#123;</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setMaximumPoolSize(int maximumPoolSize) &#123;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setKeepAliveTime(long keepAliveTime) &#123;</span><br><span class="line">        this.keepAliveTime = keepAliveTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setQueueSize(int queueSize) &#123;</span><br><span class="line">        this.queueSize = queueSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private class BlockingQueuePut implements RejectedExecutionHandler &#123;</span><br><span class="line">        /**</span><br><span class="line">         * define the reject policy when executor queue is full</span><br><span class="line">         * @see java.util.concurrent.RejectedExecutionHandler</span><br><span class="line">         * #rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)</span><br><span class="line">         */</span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">            if(blockWhenFull) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    executor.getQueue().put(r);</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setBlockWhenFull(boolean blockWhenFull) &#123;</span><br><span class="line">        this.blockWhenFull = blockWhenFull;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int getActiveCount() &#123;</span><br><span class="line">        return threadPoolExecutor.getActiveCount();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        threadPoolExecutor.shutdownNow();</span><br><span class="line">        if(scheduledExecutorService != null) &#123;</span><br><span class="line">            scheduledExecutorService.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void loopTask(Runnable task, long interval) &#123;</span><br><span class="line">        loopTask(task, interval, 0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void loopTask(Runnable task, long interval, long delay) &#123;</span><br><span class="line">        if(scheduledExecutorService == null) &#123;</span><br><span class="line">            ThreadFactory threadFactory = new BasicThreadFactory.Builder()</span><br><span class="line">            .namingPattern(&quot;schedule-pool-%d&quot;)</span><br><span class="line">            .daemon(true)</span><br><span class="line">            .build();</span><br><span class="line">            scheduledExecutorService = Executors.newScheduledThreadPool(1, threadFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(interval &lt; 100) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;不允许调度100ms以内的循环任务&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(task, delay, interval, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void runTasksUntilEnd(List&lt;Runnable&gt; tasks) &#123;</span><br><span class="line">        List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;Future&lt;?&gt;&gt;();</span><br><span class="line"> </span><br><span class="line">        for(Runnable task : tasks) &#123;</span><br><span class="line">            futures.add(addTask(task));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(Future&lt;?&gt; f : futures) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                f.get();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.warn(&quot;&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><em>ScheduledExecutorService（定时执行者服务)</em></strong><br>java.util.concurrent.ScheduledExecutorService 是一个 ExecutorService， 它能够将任务延后执行，或者间隔固定时间多次执行。 任务由一个工作者线程异步执行，而不是由提交任务给 ScheduledExecutorService 的那个线程执行。示例程序见上面的程序示例。。。</p>
<p><strong><em>ExecutouService的常见方法</em></strong></p>
<ul>
<li>execute(Runnable)：执行一个Runnable示例，用于执行不需要返回信息的任务</li>
<li>submit(Runnable)：执行一个Runnable示例，与execute的区别是它可以回查Runnable示例的执行状态</li>
<li>submit(Callable)：执行一个Callable示例，用于执行需要返回信息的任务</li>
<li>invokeAny(…)：执行一系列Callable示例，如果有一个Callable示例执行完成则其它Callable任务将被取消</li>
<li>invokeAll(…)：执行一系列Callable示例，返回所有Callable示例的执行结果</li>
</ul>
<h3 id="ForkJoinPool（分叉合并池执行池）"><a href="#ForkJoinPool（分叉合并池执行池）" class="headerlink" title="ForkJoinPool（分叉合并池执行池）"></a>ForkJoinPool（分叉合并池执行池）</h3><p>ForkJoinPool 在 Java 7 中被引入。它和 ExecutorService 很相似，除了一点不同。ForkJoinPool 让我们可以很方便地把任务分裂成几个更小的任务，这些分裂出来的任务也将会提交给 ForkJoinPool。任务可以继续分割成更小的子任务，只要它还能分割。可能听起来有些抽象，因此本节中我们将会解释 ForkJoinPool 是如何工作的，还有任务分割是如何进行的。</p>
<p><strong><em>分叉和合并解释</em></strong></p>
<p>在我们开始看 ForkJoinPool 之前我们先来简要解释一下分叉和合并的原理。<br>分叉和合并原理包含两个递归进行的步骤。两个步骤分别是分叉步骤和合并步骤</p>
<p><strong><em>分叉</em></strong><br><img src="http://incdn1.b0.upaiyun.com/2017/09/411d4e8c8ae237bdd6fc22469d1c1880.png" alt=""><br>通过把自己分割成多个子任务，每个子任务可以由不同的 CPU 并行执行，或者被同一个 CPU 上的不同线程执行。只有当给的任务过大，把它分割成几个子任务才有意义。把任务分割成子任务有一定开销，因此对于小型任务，这个分割的消耗可能比每个子任务并发执行的消耗还要大。<br>什么时候把一个任务分割成子任务是有意义的，这个界限也称作一个阀值。这要看每个任务对有意义阀值的决定。很大程度上取决于它要做的工作的种类</p>
<p><strong><em>合并</em></strong></p>
<p>当一个任务将自己分割成若干子任务之后，该任务将进入等待所有子任务的结束之中。一旦子任务执行结束，该任务可以把所有结果合并到同一个结果。图示如下：<br><img src="http://incdn1.b0.upaiyun.com/2017/09/6f5e15d2343bffb3f75201a5ad812208.png" alt=""><br>当然，并非所有类型的任务都会返回一个结果。如果这个任务并不返回一个结果，它只需等待所有子任务执行完毕。也就不需要结果的合并啦。</p>
<p><strong><em>创建一个 ForkJoinPool</em></strong></p>
<p>你可以通过其构造子创建一个 ForkJoinPool。作为传递给 ForkJoinPool 构造子的一个参数，你可以定义你期望的并行级别。并行级别表示你想要传递给 ForkJoinPool 的任务所需的线程或 CPU 数量。以下是一个 ForkJoinPool 示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool forkJoinPool = new ForkJoinPool(4);</span><br></pre></td></tr></table></figure></p>
<p><strong><em>提交任务到 ForkJoinPool</em></strong><br>就像提交任务到 ExecutorService 那样，把任务提交到 ForkJoinPool。你可以提交两种类型的任务。一种是没有任何返回值的(一个 “行动”)，另一种是有返回值的(一个”任务”)。这两种类型分别由 RecursiveAction 和 RecursiveTask 表示。接下来介绍如何使用这两种类型的任务，以及如何对它们进行提交。</p>
<p><strong><em>RecursiveAction</em></strong></p>
<p>RecursiveAction 是一种没有任何返回值的任务。它只是做一些工作，比如写数据到磁盘，然后就退出了。一个 RecursiveAction 可以把自己的工作分割成更小的几块，这样它们可以由独立的线程或者 CPU 执行。你可以通过继承来实现一个 RecursiveAction。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecursiveAction extends RecursiveAction &#123;  </span><br><span class="line">    private long workLoad = 0;  </span><br><span class="line">    public MyRecursiveAction(long workLoad) &#123;  </span><br><span class="line">        this.workLoad = workLoad;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override </span><br><span class="line">    protected void compute() &#123;  </span><br><span class="line">        </span><br><span class="line">        if(this.workLoad &gt; 16) &#123;  </span><br><span class="line">            System.out.println(&quot;Splitting workLoad : &quot; + this.workLoad);  </span><br><span class="line">            List&lt;MyRecursiveAction&gt; subtasks =  </span><br><span class="line">                new ArrayList&lt;MyRecursiveAction&gt;();  </span><br><span class="line">            subtasks.addAll(createSubtasks());  </span><br><span class="line">            for(RecursiveAction subtask : subtasks)&#123;  </span><br><span class="line">                subtask.fork();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            System.out.println(&quot;Doing workLoad myself: &quot; + this.workLoad);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    private List&lt;MyRecursiveAction&gt; createSubtasks() &#123;  </span><br><span class="line">        List&lt;MyRecursiveAction&gt; subtasks =  </span><br><span class="line">            new ArrayList&lt;MyRecursiveAction&gt;();  </span><br><span class="line">        MyRecursiveAction subtask1 = new MyRecursiveAction(this.workLoad / 2);  </span><br><span class="line">        MyRecursiveAction subtask2 = new MyRecursiveAction(this.workLoad / 2);  </span><br><span class="line">        subtasks.add(subtask1);  </span><br><span class="line">        subtasks.add(subtask2);  </span><br><span class="line">        return subtasks;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子很简单。MyRecursiveAction 将一个虚构的 workLoad 作为参数传给自己的构造子。如果 workLoad 高于一个特定阀值，该工作将被分割为几个子工作，子工作继续分割。如果 workLoad 低于特定阀值，该工作将由 MyRecursiveAction 自己执行。你可以这样规划一个 MyRecursiveAction 的执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyRecursiveAction myRecursiveAction = new MyRecursiveAction(24);  </span><br><span class="line">forkJoinPool.invoke(myRecursiveAction);</span><br></pre></td></tr></table></figure></p>
<p><strong><em>RecursiveTask</em></strong><br>RecursiveTask 是一种会返回结果的任务。它可以将自己的工作分割为若干更小任务，并将这些子任务的执行结果合并到一个集体结果。可以有几个水平的分割和合并。以下是一个 RecursiveTask 示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecursiveTask extends RecursiveTask&lt;Long&gt;</span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line">        private long workLoad = 0;  </span><br><span class="line">	    public MyRecursiveTask(long workLoad)&#123;  </span><br><span class="line">	        this.workLoad = workLoad;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    protected Long compute () &#123;  </span><br><span class="line">	        </span><br><span class="line">	        if (this.workLoad &gt; 16)&#123;  </span><br><span class="line">	            System.out.println(&quot;Splitting workLoad : &quot;  + this.workLoad);  </span><br><span class="line">	            List&lt;MyRecursiveTask&gt; subtasks =  </span><br><span class="line">	                new ArrayList&lt;MyRecursiveTask&gt; ();  </span><br><span class="line">	            subtasks.addAll(createSubtasks());  </span><br><span class="line">	            for (MyRecursiveTask subtask : subtasks) &#123;  </span><br><span class="line">	                subtask.fork();  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            long result = 0;  </span><br><span class="line">	            for (MyRecursiveTask subtask : subtasks) &#123;  </span><br><span class="line">	                result += subtask.join();  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            return result;  </span><br><span class="line">	        &#125; else &#123;  </span><br><span class="line">	            System.out.println(&quot;Doing workLoad myself: &quot;  + this.workLoad);  </span><br><span class="line">	            return workLoad * 3;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    private List&lt;MyRecursiveTask&gt; createSubtasks () &#123;  </span><br><span class="line">	        List&lt;MyRecursiveTask&gt; subtasks =  </span><br><span class="line">	        new ArrayList&lt;MyRecursiveTask&gt; ();  </span><br><span class="line">	        MyRecursiveTask subtask1 = new MyRecursiveTask(this.workLoad / 2);  </span><br><span class="line">	        MyRecursiveTask subtask2 = new MyRecursiveTask(this.workLoad / 2);  </span><br><span class="line">	        subtasks.add(subtask1);  </span><br><span class="line">	        subtasks.add(subtask2);  </span><br><span class="line">	        return subtasks;  </span><br><span class="line">	    &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>除了有一个结果返回之外，这个示例和 RecursiveAction 的例子很像。MyRecursiveTask 类继承自 RecursiveTask<long>，这也就意味着它将返回一个 Long 类型的结果。MyRecursiveTask 示例也会将工作分割为子任务，并通过 fork() 方法对这些子任务计划执行。此外，本示例还通过调用每个子任务的 join() 方法收集它们返回的结果。子任务的结果随后被合并到一个更大的结果，并最终将其返回。对于不同级别的递归，这种子任务的结果合并可能会发生递归。</long></p>
<p>你可以这样规划一个 RecursiveTask：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyRecursiveTask myRecursiveTask = new MyRecursiveTask(128);  </span><br><span class="line">long mergedResult = forkJoinPool.invoke(myRecursiveTask);  </span><br><span class="line">System.out.println(&quot;mergedResult = &quot; + mergedResult);</span><br></pre></td></tr></table></figure></p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>java.util.concurrent.locks.Lock 是一个类似于 synchronized 块的线程同步机制。但是 Lock 比 synchronized 块更加灵活、精细。java.util.concurrent.locks中提供了lock的实现ReentrantLock。</p>
<p><strong><em>Lock 和 synchronized 代码块的主要不同点</em></strong><br>一个 Lock 对象和一个 synchronized 代码块之间的主要不同点是：</p>
<ul>
<li>synchronized 代码块不能够保证进入访问等待的线程的先后顺序</li>
<li>你不能够传递任何参数给一个 synchronized 代码块的入口。因此，对于 synchronized 代码块的访问等待设置超时时间是不可能的事情。</li>
<li>synchronized 块必须被完整地包含在单个方法里。而一个 Lock 对象可以把它的 lock() 和 unlock() 方法的调用放在不同的方法里。</li>
</ul>
<p>Lock 接口具有以下主要方法：</p>
<ul>
<li>lock()：将lock实例锁定，如果lock实例已被其他线程锁定则该方法阻塞，直到lock实例被解锁</li>
<li>lockInterruptibly()：锁定lock实例，除非该线程被打断。如果一旦因Lock实例已被锁定而进入阻塞，则如果它被外部打断则退出该方法的调用。</li>
<li>tryLock()：以永不阻塞的方式尝试锁定lock实例，若锁定成功立即返回true,否则若lock实例已被锁定立即返回false</li>
<li>tryLock(long timeout, TimeUnit timeUnit)：与tryLock()类似，只是它能指定在放弃锁定之前的最长等待时间。</li>
<li>unlock()：解锁lock实例，只允许锁定相应lock实例的线程调用该方法，否则抛出一个未检查异常。</li>
</ul>
<p><strong><em>ReentrantLock</em></strong></p>
<p>lock的基本实现，使用简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();  </span><br><span class="line">…….</span><br><span class="line">lock.lock();  </span><br><span class="line">…….</span><br><span class="line">…….</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure></p>
<p><strong><em>ReadWriteLock</em></strong></p>
<p>java.util.concurrent.locks.ReadWriteLock 读写锁是一种先进的线程锁机制。它能够允许多个线程在同一时间对某特定资源进行读取，但同一时间内只能有一个线程对其进行写入。</p>
<p>读写锁的理念在于多个线程能够对一个共享资源进行读取，而不会导致并发问题。并发问题的发生场景在于对一个共享资源的读和写操作的同时进行，或者多个写操作并发进行。</p>
<p>ReadWriteLock 锁规则</p>
<p>一个线程在对受保护资源在读或者写之前对 ReadWriteLock 锁定的规则如下：</p>
<ul>
<li><strong><em>读锁</em></strong>：如果没有任何写操作线程锁定 ReadWriteLock，并且没有任何写操作线程要求一个写锁(但还没有获得该锁)。因此，可以有多个读操作线程对该锁进行锁定。</li>
<li><strong><em>写锁</em></strong>：如果没有任何读操作或者写操作。因此，在写操作的时候，只能有一个线程对该锁进行锁定。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();</span><br><span class="line">reentrantReadWriteLock.readLock().lock();</span><br><span class="line"> …..</span><br><span class="line"> </span><br><span class="line">reentrantReadWriteLock.readLock().unlock();</span><br><span class="line"> </span><br><span class="line">reentrantReadWriteLock.writeLock().lock();</span><br><span class="line"> …….</span><br><span class="line"> </span><br><span class="line">reentrantReadWriteLock.writeLock().unlock();</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/12/24/JAVA-oncurrent包学习总结/">JAVA oncurrent包学习总结</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">smartcong007</a></p>
        <p><span>发布时间:</span>2017-12-24, 17:26:03</p>
        <p><span>最后更新:</span>2018-01-13, 16:28:25</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/12/24/JAVA-oncurrent包学习总结/" title="JAVA oncurrent包学习总结">http://yoursite.com/2017/12/24/JAVA-oncurrent包学习总结/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2017/12/24/JAVA-oncurrent包学习总结/　　作者: smartcong007" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/01/17/Spring源码持续学习-一/">
                    Spring源码持续学习(一)
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/12/20/浅析zookeeper的典型应用场景/">
                    浅析zookeeper的典型应用场景
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞队列"><span class="toc-number">1.</span> <span class="toc-text"><a href="#&#x963B;&#x585E;&#x961F;&#x5217;" class="headerlink" title="&#x963B;&#x585E;&#x961F;&#x5217;"></a>&#x963B;&#x585E;&#x961F;&#x5217;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">1.0.1.</span> <span class="toc-text"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DelayQueue"><span class="toc-number">1.0.2.</span> <span class="toc-text"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">1.0.3.</span> <span class="toc-text"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityBlockingQueue"><span class="toc-number">1.0.4.</span> <span class="toc-text"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">1.0.5.</span> <span class="toc-text"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双端阻塞队列-BlockingDeque"><span class="toc-number">2.</span> <span class="toc-text"><a href="#&#x53CC;&#x7AEF;&#x963B;&#x585E;&#x961F;&#x5217;-BlockingDeque" class="headerlink" title="&#x53CC;&#x7AEF;&#x963B;&#x585E;&#x961F;&#x5217;(BlockingDeque)"></a>&#x53CC;&#x7AEF;&#x963B;&#x585E;&#x961F;&#x5217;(BlockingDeque)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发集合"><span class="toc-number">3.</span> <span class="toc-text"><a href="#&#x5E76;&#x53D1;&#x96C6;&#x5408;" class="headerlink" title="&#x5E76;&#x53D1;&#x96C6;&#x5408;"></a>&#x5E76;&#x53D1;&#x96C6;&#x5408;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#headMap"><span class="toc-number">3.0.1.</span> <span class="toc-text"><a href="#headMap" class="headerlink" title="headMap()"></a>headMap()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tailMap"><span class="toc-number">3.0.2.</span> <span class="toc-text"><a href="#tailMap" class="headerlink" title="tailMap()"></a>tailMap()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#subMap"><span class="toc-number">3.0.3.</span> <span class="toc-text"><a href="#subMap" class="headerlink" title="subMap()"></a>subMap()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见并发工具"><span class="toc-number">4.</span> <span class="toc-text"><a href="#&#x5E38;&#x89C1;&#x5E76;&#x53D1;&#x5DE5;&#x5177;" class="headerlink" title="&#x5E38;&#x89C1;&#x5E76;&#x53D1;&#x5DE5;&#x5177;"></a>&#x5E38;&#x89C1;&#x5E76;&#x53D1;&#x5DE5;&#x5177;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch（闭锁）"><span class="toc-number">4.1.</span> <span class="toc-text"><a href="#CountDownLatch&#xFF08;&#x95ED;&#x9501;&#xFF09;" class="headerlink" title="CountDownLatch&#xFF08;&#x95ED;&#x9501;&#xFF09;"></a>CountDownLatch&#xFF08;&#x95ED;&#x9501;&#xFF09;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier（栅栏）"><span class="toc-number">4.2.</span> <span class="toc-text"><a href="#CyclicBarrier&#xFF08;&#x6805;&#x680F;&#xFF09;" class="headerlink" title="CyclicBarrier&#xFF08;&#x6805;&#x680F;&#xFF09;"></a>CyclicBarrier&#xFF08;&#x6805;&#x680F;&#xFF09;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exchanger-交换机"><span class="toc-number">4.3.</span> <span class="toc-text"><a href="#Exchanger-&#x4EA4;&#x6362;&#x673A;" class="headerlink" title="Exchanger(&#x4EA4;&#x6362;&#x673A;)"></a>Exchanger(&#x4EA4;&#x6362;&#x673A;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore-信号量"><span class="toc-number">4.4.</span> <span class="toc-text"><a href="#Semaphore-&#x4FE1;&#x53F7;&#x91CF;" class="headerlink" title="Semaphore(&#x4FE1;&#x53F7;&#x91CF;)"></a>Semaphore(&#x4FE1;&#x53F7;&#x91CF;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExecutorService-执行器服务"><span class="toc-number">4.5.</span> <span class="toc-text"><a href="#ExecutorService-&#x6267;&#x884C;&#x5668;&#x670D;&#x52A1;" class="headerlink" title="ExecutorService(&#x6267;&#x884C;&#x5668;&#x670D;&#x52A1;)"></a>ExecutorService(&#x6267;&#x884C;&#x5668;&#x670D;&#x52A1;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinPool（分叉合并池执行池）"><span class="toc-number">4.6.</span> <span class="toc-text"><a href="#ForkJoinPool&#xFF08;&#x5206;&#x53C9;&#x5408;&#x5E76;&#x6C60;&#x6267;&#x884C;&#x6C60;&#xFF09;" class="headerlink" title="ForkJoinPool&#xFF08;&#x5206;&#x53C9;&#x5408;&#x5E76;&#x6C60;&#x6267;&#x884C;&#x6C60;&#xFF09;"></a>ForkJoinPool&#xFF08;&#x5206;&#x53C9;&#x5408;&#x5E76;&#x6C60;&#x6267;&#x884C;&#x6C60;&#xFF09;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-number">4.7.</span> <span class="toc-text"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    

    
        <div class="addthis_sharing_toolbox"></div>
    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/01/17/Spring源码持续学习-一/" title="上一篇: Spring源码持续学习(一)">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/12/20/浅析zookeeper的典型应用场景/" title="下一篇: 浅析zookeeper的典型应用场景">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/24/Spring源码持续学习-二/">Spring源码持续学习(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/17/Spring源码持续学习-一/">Spring源码持续学习(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/24/JAVA-oncurrent包学习总结/">JAVA oncurrent包学习总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/浅析zookeeper的典型应用场景/">浅析zookeeper的典型应用场景</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 smartcong007
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>