<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="smartcong007" />



<meta name="description" content="一直零零散散地看网上关于spring源码的一些解读，始终不能静下心来自己独立解读一番spring的基础源码，这次强行敦促自己借助空闲时间来独立持续学习spring源码相关的东西。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码持续学习(一)">
<meta property="og:url" content="http://yoursite.com/2018/01/17/Spring源码持续学习-一/index.html">
<meta property="og:site_name" content="smartcong007">
<meta property="og:description" content="一直零零散散地看网上关于spring源码的一些解读，始终不能静下心来自己独立解读一番spring的基础源码，这次强行敦促自己借助空闲时间来独立持续学习spring源码相关的东西。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-01-23T07:20:09.082Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring源码持续学习(一)">
<meta name="twitter:description" content="一直零零散散地看网上关于spring源码的一些解读，始终不能静下心来自己独立解读一番spring的基础源码，这次强行敦促自己借助空闲时间来独立持续学习spring源码相关的东西。">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="smartcong007" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Spring源码持续学习(一) | smartcong007</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>



    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5a3f5dab49b144d6"></script>




</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/paprika.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">smartcong007</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:cong99299618@hotmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/smartcong007" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 网易云音乐" href="http://music.163.com/#/user/home?id=104362235" title="网易云音乐"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">服务端大搞，架构中搞，前端小搞</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">smartcong007</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/paprika.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">smartcong007</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:cong99299618@hotmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/smartcong007" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="http://music.163.com/#/user/home?id=104362235" title="网易云音乐"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-Spring源码持续学习-一" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/17/Spring源码持续学习-一/" class="article-date">
      <time datetime="2018-01-17T06:25:20.000Z" itemprop="datePublished">2018-01-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring源码持续学习(一)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>Spring一直在用，从早期的直接使用spring到现在工作中使用公司定制版的spring，不管是哪种形式的spring的变种，都是依附于spring本身的特性作一些功能上的定制。要理解到spring本身的一些特性就必须要读其源码，所以干就是了。。。</p>
</blockquote>
<h2 id="IOC容器的初始化"><a href="#IOC容器的初始化" class="headerlink" title="IOC容器的初始化"></a>IOC容器的初始化</h2><p>ioc容器是spring的核心部分，一个基于spring的应用程序的生命周期中一个最重要的过程就是ioc容器的初始化。我们日常使用spring就知道，整个容器的初始化依赖于配置文件的读取和解析。具体展开来说就是以下三个步骤：</p>
<ul>
<li>由ResourceLoader通过统一的Resource接口来定位不同形式的bean配置文件</li>
<li>通过对定位到的resource文件解析得到相应的BeanDefinition，BeanDefinition实质上是外部对象在ioc容器内部对应的数据结构表示。</li>
<li>向Ioc容器中注册已经 解析的BeanDefinition,存放到对应的beanDefinitionMap中</li>
</ul>
<p>而日常工作中我们大多以xml的形式配置spring(虽然早在官方4.0版本就开始推崇java的形式配置spring)，所以在此还是以xml配置文件为例分析配置文件完整的载入、解析过程。</p>
<p>先来看加载xml配置文件的入口部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);</span><br><span class="line">MediaCluesSellCarInfoDao mediaCluesSellCarInfoDao = (MediaCluesSellCarInfoDao) context.getBean(&quot;mediaCluesSellCarInfoDao&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这里是常见的从类路径下读取配置文件，当然还有从整个文件系统，应用下读取配置文件的方法。第一行代码其实就代表整个加载过程的总入口了，只需要从第一行代码进去分析。这里用到了ClassPathXmlApplicationContext的构造函数之一：ClassPathXmlApplicationContext(String configLocation)，进去看这个构造函数发现它其实还是调用了另一个基础的构造函数：ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)。下面进去分析这个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		super(parent);</span><br><span class="line">		setConfigLocations(configLocations);</span><br><span class="line">		if (refresh) &#123;</span><br><span class="line">			refresh();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一行是初始化时配置父容器(最常见的一个配置文件中import了其他配置文件),这里只是单纯的设置一下父ApplicationContext，不用详谈。第二行用于本地记录spring配置文件的路径并初步解析替换配置文件中可能用到的系统占位符。可以进去看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setConfigLocations(String... locations) &#123;</span><br><span class="line">		if (locations != null) &#123;</span><br><span class="line">			Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);</span><br><span class="line">			this.configLocations = new String[locations.length];</span><br><span class="line">			for (int i = 0; i &lt; locations.length; i++) &#123;</span><br><span class="line">				this.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			this.configLocations = null;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到将配置文件进行了一次resolvePath的操作后才转存成相应的path数组，进去瞧瞧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected String resolvePath(String path) &#123;</span><br><span class="line">		return getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到没有，这里对原始路径的配置文件进行了resolveRequiredPlaceholders的操作，看名字就猜得到这个方法就是进行占位符的解析。其实这里只要明白了其用意就可以打住了。接下来可以想象就是把配置文件中的占位符替换成具体的系统环境变量(如：System.dir)的过程。我们退到最初的ClassPathXmlApplicationContext的构造函数中进入最核心的一步：refresh()。也就是整个容器的刷新函数，进去详加分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">		synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">			// Prepare this context for refreshing.</span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			// Prepare the bean factory for use in this context.</span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Invoke factory processors registered as beans in the context.</span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Register bean processors that intercept bean creation.</span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Initialize message source for this context.</span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				// Initialize event multicaster for this context.</span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				// Initialize other special beans in specific context subclasses.</span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				// Check for listener beans and register them.</span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Last step: publish corresponding event.</span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				if (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">							&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				// Reset &apos;active&apos; flag.</span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				// Propagate exception to caller.</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			finally &#123;</span><br><span class="line">				// Reset common introspection caches in Spring&apos;s core, since we</span><br><span class="line">				// might not ever need metadata for singleton beans anymore...</span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以清晰的看到spring将容器的刷新过程分成好几个子步骤来完成，refresh()中调用的每一个子方法对应一个子步骤。这样一来是因为整个refresh操作涉及的东西太多需要分拆解耦，二来是为了增强其扩展性。这里需要耐心地按顺序逐个解析。</p>
<p><em>prepareRefresh</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareRefresh() &#123;</span><br><span class="line">		this.startupDate = System.currentTimeMillis();</span><br><span class="line">		this.closed.set(false);</span><br><span class="line">		this.active.set(true);</span><br><span class="line"></span><br><span class="line">		if (logger.isInfoEnabled()) &#123;</span><br><span class="line">			logger.info(&quot;Refreshing &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Initialize any placeholder property sources in the context environment</span><br><span class="line">		initPropertySources();</span><br><span class="line"></span><br><span class="line">		// Validate that all properties marked as required are resolvable</span><br><span class="line">		// see ConfigurablePropertyResolver#setRequiredProperties</span><br><span class="line">		getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">		// Allow for the collection of early ApplicationEvents,</span><br><span class="line">		// to be published once the multicaster is available...</span><br><span class="line">		this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前三行用于设置一些标志位和上下文刷新的开始时间，initPropertySources()方法从注释可以看出是初始化配置文件中自定义占位符对应的properties信息，默认为空方法可供开发者自行扩展,getEnvironment().validateRequiredProperties()用于校验配置文件中那些必需的属性是否都能解析到。</p>
<p><em>obtainFreshBeanFactory</em><br>第二步就是获取刷新spring上下文的bean工厂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">		refreshBeanFactory();</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line">		return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>核心的还是第一行refreshBeanFactory(),刷新bean工厂，进去看看:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">		if (hasBeanFactory()) &#123;</span><br><span class="line">			destroyBeans();</span><br><span class="line">			closeBeanFactory();</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">			beanFactory.setSerializationId(getId());</span><br><span class="line">			customizeBeanFactory(beanFactory);</span><br><span class="line">			loadBeanDefinitions(beanFactory);</span><br><span class="line">			synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">				this.beanFactory = beanFactory;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到代码中前四行销毁当前已经存在的bean工厂(如果有的话)，后面再新建一个bean工厂，这里可以看出新建的bean工厂是DefaultListableBeanFactory类型的，然后对新的bean工厂作一些初始化工作，初始化中最重要的是loadBeanDefinitions(beanFactory)，进去看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">		// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br><span class="line">		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">		// Configure the bean definition reader with this context&apos;s</span><br><span class="line">		// resource loading environment.</span><br><span class="line">		beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">		beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">		// Allow a subclass to provide custom initialization of the reader,</span><br><span class="line">		// then proceed with actually loading the bean definitions.</span><br><span class="line">		initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">		loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实loadBeanDefinitions有多种实现，取决于bean以何种形式配置，这里bean是以xml文件的形式配置的，自然而然要看AbstractXmlApplicationContext的实现。从代码中可以看出加载bean的信息要用到XmlBeanDefinitionReader实例，所以这里先通过先前初始化的beanFactory实例化一个XmlBeanDefinitionReader，实例化后还用用当前的context的资源加载环境初始化它。最后一行是最核心的一步，进去看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">		Resource[] configResources = getConfigResources();</span><br><span class="line">		if (configResources != null) &#123;</span><br><span class="line">			reader.loadBeanDefinitions(configResources);</span><br><span class="line">		&#125;</span><br><span class="line">		String[] configLocations = getConfigLocations();</span><br><span class="line">		if (configLocations != null) &#123;</span><br><span class="line">			reader.loadBeanDefinitions(configLocations);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里默认情况下其实还是根据配置文件的路径来加载BeanDefinition，因为getConfigResources()进去看是一个空方法，也就是这里留下了一个扩展点，可以通过重写这个方法来提供一些预置的配置源，这样加载BeanDefinition将先从这些预置的配置源加载，然后才是从最开始传入的路径信息加载。接着顺藤摸瓜进入加载单个源文件的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);</span><br><span class="line">        if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">            this.logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;EncodedResource&gt; currentResources = (Set)this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">        if (currentResources == null) &#123;</span><br><span class="line">            currentResources = new HashSet(4);</span><br><span class="line">            this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!((Set)currentResources).add(encodedResource)) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int var5;</span><br><span class="line">            try &#123;</span><br><span class="line">                InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">                    if (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">                        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    var5 = this.doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException var15) &#123;</span><br><span class="line">                throw new BeanDefinitionStoreException(&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), var15);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                ((Set)currentResources).remove(encodedResource);</span><br><span class="line">                if (((Set)currentResources).isEmpty()) &#123;</span><br><span class="line">                    this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return var5;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在进入这个方法之前其实省略了一些部分，其实重点就是作了从location得到EncodedResource的过程，不是关注的重点不用在意。接着看这段代码，其实这段代码的重点可以总结为先把EncodedResource转化成InputSource，因为用SAX API读取xml文件使都要从InputSource开始，然后进入doLoadBeanDefinitions(inputSource, encodedResource.getResource())：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Document doc = this.doLoadDocument(inputSource, resource);</span><br><span class="line">return this.registerBeanDefinitions(doc, resource);</span><br></pre></td></tr></table></figure></p>
<p>这里为了节省篇幅只截取关键的两行代码，第一行就是通过前面的的InputSource和Resource对象生成一个Document对象，Document对象是java中处理xml文件的基础对象，Document对象中就包含了xml文件中对应的所有节点信息。进第二行继续看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        BeanDefinitionDocumentReader documentReader = this.createBeanDefinitionDocumentReader();</span><br><span class="line">        int countBefore = this.getRegistry().getBeanDefinitionCount();</span><br><span class="line">        documentReader.registerBeanDefinitions(doc, this.createReaderContext(resource));</span><br><span class="line">        return this.getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过BeanDefinitionDocumentReader来从Document中读取bean信息并注册成为最终的BeanDefinition，继续看registerBeanDefinitions方法直接进入doRegisterBeanDefinitions方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">        BeanDefinitionParserDelegate parent = this.delegate;</span><br><span class="line">        this.delegate = this.createDelegate(this.getReaderContext(), root, parent);</span><br><span class="line">        if (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            String profileSpec = root.getAttribute(&quot;profile&quot;);</span><br><span class="line">            if (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, &quot;,; &quot;);</span><br><span class="line">                if (!this.getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">                        this.logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + this.getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.preProcessXml(root);</span><br><span class="line">        this.parseBeanDefinitions(root, this.delegate);</span><br><span class="line">        this.postProcessXml(root);</span><br><span class="line">        this.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的root是前面的Doucument的根节点元素,可以看到这里对Doucument的解析依赖于一个委托类BeanDefinitionParserDelegate，默认BeanDefinitionParserDelegate会处理<a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a>命名空间下元素及其属性,查看源码可以看到BeanDefinitionParserDelegate下面定义了一堆元素和属性名称,这些元素和属性名称分别可以在类中找到处理方法.然后进入parseBeanDefinitions方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            NodeList nl = root.getChildNodes();</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; nl.getLength(); ++i) &#123;</span><br><span class="line">                Node node = nl.item(i);</span><br><span class="line">                if (node instanceof Element) &#123;</span><br><span class="line">                    Element ele = (Element)node;</span><br><span class="line">                    if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                        this.parseDefaultElement(ele, delegate);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        delegate.parseCustomElement(ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            delegate.parseCustomElement(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这儿有一点比较麻烦，就是解析默认命名空间下的标签(如bean,import,beans,alias)和其它命名空间下的标签(如aop、jdbc,context:component-scan等)是分开的，先看解析默认标签parseDefaultElement:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        if (delegate.nodeNameEquals(ele, &quot;import&quot;)) &#123;</span><br><span class="line">            this.importBeanDefinitionResource(ele);</span><br><span class="line">        &#125; else if (delegate.nodeNameEquals(ele, &quot;alias&quot;)) &#123;</span><br><span class="line">            this.processAliasRegistration(ele);</span><br><span class="line">        &#125; else if (delegate.nodeNameEquals(ele, &quot;bean&quot;)) &#123;</span><br><span class="line">            this.processBeanDefinition(ele, delegate);</span><br><span class="line">        &#125; else if (delegate.nodeNameEquals(ele, &quot;beans&quot;)) &#123;</span><br><span class="line">            this.doRegisterBeanDefinitions(ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清晰地看到针对不同的标签分别调用相应的处理方法，这里重点看一下对<bean>的处理processBeanDefinition:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">        if (bdHolder != null) &#123;</span><br><span class="line">            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry());</span><br><span class="line">            &#125; catch (BeanDefinitionStoreException var5) &#123;</span><br><span class="line">                this.getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></bean></p>
<p>重点是第一行代码解析bean标签并生成BeanDefinitionHolder，后面就是把生成的BeanDefinitionHolder注册到DefaultListableBeanFactory的beanDefinitionMap中。进入parseBeanDefinitionElement看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class="line">        String id = ele.getAttribute(&quot;id&quot;);</span><br><span class="line">        String nameAttr = ele.getAttribute(&quot;name&quot;);</span><br><span class="line">        List&lt;String&gt; aliases = new ArrayList();</span><br><span class="line">        if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, &quot;,; &quot;);</span><br><span class="line">            aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String beanName = id;</span><br><span class="line">        if (!StringUtils.hasText(id) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            beanName = (String)aliases.remove(0);</span><br><span class="line">            if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                this.logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName + &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (containingBean == null) &#123;</span><br><span class="line">            this.checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbstractBeanDefinition beanDefinition = this.parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">        if (beanDefinition != null) &#123;</span><br><span class="line">            if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (containingBean != null) &#123;</span><br><span class="line">                        beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                        String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                        if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                            aliases.add(beanClassName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                        this.logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception var9) &#123;</span><br><span class="line">                    this.error(var9.getMessage(), ele);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">            return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码首先给这个Element对应的bean起名字，然后生成相应的BeanDefinition，最后将生成的BeanDefinition包装成BeanDefinitionHolder。第一步值得注意的一点是获取bean的名字时是优先选用id作为名字，如果bean没有指定id则利用name来生成名字。接下来看关键一步parseBeanDefinitionElement：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line">        this.parseState.push(new BeanEntry(beanName));</span><br><span class="line">        String className = null;</span><br><span class="line">        if (ele.hasAttribute(&quot;class&quot;)) &#123;</span><br><span class="line">            className = ele.getAttribute(&quot;class&quot;).trim();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            String parent = null;</span><br><span class="line">            if (ele.hasAttribute(&quot;parent&quot;)) &#123;</span><br><span class="line">                parent = ele.getAttribute(&quot;parent&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbstractBeanDefinition bd = this.createBeanDefinition(className, parent);</span><br><span class="line">            this.parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">            bd.setDescription(DomUtils.getChildElementValueByTagName(ele, &quot;description&quot;));</span><br><span class="line">            this.parseMetaElements(ele, bd);</span><br><span class="line">            this.parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">            this.parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">            this.parseConstructorArgElements(ele, bd);</span><br><span class="line">            this.parsePropertyElements(ele, bd);</span><br><span class="line">            this.parseQualifierElements(ele, bd);</span><br><span class="line">            bd.setResource(this.readerContext.getResource());</span><br><span class="line">            bd.setSource(this.extractSource(ele));</span><br><span class="line">            AbstractBeanDefinition var7 = bd;</span><br><span class="line">            return var7;</span><br><span class="line">        &#125; catch (ClassNotFoundException var13) &#123;</span><br><span class="line">            this.error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, var13);</span><br><span class="line">        &#125; catch (NoClassDefFoundError var14) &#123;</span><br><span class="line">            this.error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, var14);</span><br><span class="line">        &#125; catch (Throwable var15) &#123;</span><br><span class="line">            this.error(&quot;Unexpected failure during bean definition parsing&quot;, ele, var15);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            this.parseState.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以清晰地看到做的事儿就是解析bean标签的各种属性。这里先利用element的className和parent属性生成AbstractBeanDefinition的实例bd，然后调用parseBeanDefinitionAttributes方法继续获取element的scope、lazy-init、abstract、depends-on属性等等并设置到bd中，最后还要解析element的构造参数，meta，lookup-method等一系列跟bean初始化相关的属性到bd中，然后就返回了element解析来的完整的BeanDefinition了。最后回到上一步的parseBeanDefinitionElement方法中用包装类BeanDefinitionHolder将BeanDefinition包装一下，最后回到processBeanDefinition中注册BeanDefinition到DefaultListableBeanFactory的beanDefinitionMap中。</p>
<p>接下来说说非默认命名空间下的元素的解析，对非默认命名空间下元素的解析依赖于一个委托类BeanDefinitionParserDelegate的parseCustomElement方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123;</span><br><span class="line">        String namespaceUri = this.getNamespaceURI(ele);</span><br><span class="line">        NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">        if (handler == null) &#123;</span><br><span class="line">            this.error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从以上代码可以看出是先根据元素找到匹配的命名空间namespaceUri（例如<a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a>，哈哈现在知道xml文件最开头的元素前缀与命名空间的映射声明有何卵用了），然后用这个namespaceUri找到对应的NamespaceHandler实例，然后调用NamespaceHandler对应的parse方法来处理对应元素。比如”<context:component-scan>“最终得到的是ContextNameSpaceHandler。对命名空间的解析主要是这一句this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri)，先获取当前xmlReaderContext下的NamespaceHandlerResolver，然后调用对应的resolve方法，看一下这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public NamespaceHandler resolve(String namespaceUri) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; handlerMappings = this.getHandlerMappings();</span><br><span class="line">        Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">        if (handlerOrClassName == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123;</span><br><span class="line">            return (NamespaceHandler)handlerOrClassName;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String className = (String)handlerOrClassName;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader);</span><br><span class="line">                if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">                    throw new FatalBeanException(&quot;Class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri + &quot;] does not implement the [&quot; + NamespaceHandler.class.getName() + &quot;] interface&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    NamespaceHandler namespaceHandler = (NamespaceHandler)BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">                    namespaceHandler.init();</span><br><span class="line">                    handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">                    return namespaceHandler;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException var7) &#123;</span><br><span class="line">                throw new FatalBeanException(&quot;NamespaceHandler class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri + &quot;] not found&quot;, var7);</span><br><span class="line">            &#125; catch (LinkageError var8) &#123;</span><br><span class="line">                throw new FatalBeanException(&quot;Invalid NamespaceHandler class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri + &quot;]: problem with handler class file or dependent class&quot;, var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></context:component-scan></p>
<p>以上代码中先得到一个命名空间与命名空间对应解析类的映射Map,怎么得到的还要看getHandlerMappings():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Object&gt; getHandlerMappings() &#123;</span><br><span class="line">        if (this.handlerMappings == null) &#123;</span><br><span class="line">            synchronized(this) &#123;</span><br><span class="line">                if (this.handlerMappings == null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);</span><br><span class="line">                        if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            this.logger.debug(&quot;Loaded NamespaceHandler mappings: &quot; + mappings);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Map&lt;String, Object&gt; handlerMappings = new ConcurrentHashMap(mappings.size());</span><br><span class="line">                        CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);</span><br><span class="line">                        this.handlerMappings = handlerMappings;</span><br><span class="line">                    &#125; catch (IOException var5) &#123;</span><br><span class="line">                        throw new IllegalStateException(&quot;Unable to load NamespaceHandler mappings from location [&quot; + this.handlerMappingsLocation + &quot;]&quot;, var5);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this.handlerMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码不复杂，大致意思是先从指定位置读取Properties配置文件，这个指定位置其实是NamespaceHandlerResolver在初始化时就指定好了的，在代码的第一行public static final String DEFAULT_HANDLER_MAPPINGS_LOCATION = “META-INF/spring.handlers”;也就是去类路径下加载所有META-INF下的spring.handlers，例如我们可以找到spring-context jar包下的META-INF/spring.handlers文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</span><br></pre></td></tr></table></figure></p>
<p>显然可以想到在上面resolve()一开始获取的handlerMappings就是各个Jar包下的spring.handlers文件转换来的，继续看resolve()接下来做的事：从handlerMappings中根据命名空间地址获取对应的命名空间解析类，如果这个解析类已经是NamespaceHandler类型的则直接返回，否则根据这个解析类的类名强制重新加载NamespaceHandler类型的类并返回，这样下来最初的<a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a>最终就被解析成了ContextNamespaceHandler类。然后看ContextNamespaceHandler中的parse():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">        return this.findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对不起，即使到了ContextNamespaceHandler下还是不能直接解析标签，因为大家都知道挂在<a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a>命名空间下的标签不止一个，还有多个，我们可以看ContextNamespaceHandler的init方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void init() &#123;</span><br><span class="line">		registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到了吧，不止一个 <context:component-scan> ,还有如 <context:property-placeholder> 等7个标签。所以ContextNamespaceHandler的parse方法需要先根据标签名得到对应的BeanDefinitionParser对象，也就是this.findParserForElement(element, parserContext)。例如component-scan得到的是ComponentScanBeanDefinitionParser。最后调用Parse类中的parse()对元素解析，例如我们看ComponentScanBeanDefinitionParser:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   private static final String BASE_PACKAGE_ATTRIBUTE = &quot;base-package&quot;;</span><br><span class="line"></span><br><span class="line">private static final String RESOURCE_PATTERN_ATTRIBUTE = &quot;resource-pattern&quot;;</span><br><span class="line"></span><br><span class="line">private static final String USE_DEFAULT_FILTERS_ATTRIBUTE = &quot;use-default-filters&quot;;</span><br><span class="line"></span><br><span class="line">private static final String ANNOTATION_CONFIG_ATTRIBUTE = &quot;annotation-config&quot;;</span><br><span class="line"></span><br><span class="line">private static final String NAME_GENERATOR_ATTRIBUTE = &quot;name-generator&quot;;</span><br><span class="line"></span><br><span class="line">private static final String SCOPE_RESOLVER_ATTRIBUTE = &quot;scope-resolver&quot;;</span><br><span class="line"></span><br><span class="line">private static final String SCOPED_PROXY_ATTRIBUTE = &quot;scoped-proxy&quot;;</span><br><span class="line"></span><br><span class="line">private static final String EXCLUDE_FILTER_ELEMENT = &quot;exclude-filter&quot;;</span><br><span class="line"></span><br><span class="line">private static final String INCLUDE_FILTER_ELEMENT = &quot;include-filter&quot;;</span><br><span class="line"></span><br><span class="line">private static final String FILTER_TYPE_ATTRIBUTE = &quot;type&quot;;</span><br><span class="line"></span><br><span class="line">private static final String FILTER_EXPRESSION_ATTRIBUTE = &quot;expression&quot;;</span><br></pre></td></tr></table></figure></context:property-placeholder></context:component-scan></p>
<p>看到没有，ComponentScanBeanDefinitionParser类的属性就包含了<comtext:component:scan>的所有属性，例如常见的base-package。然后ComponentScanBeanDefinitionParser包含了相应的parse()去解析标签并直接注册到context中。</comtext:component:scan></p>
<p>这一篇分析下来头皮发麻，顺藤摸瓜式的读源码是一种享受吧☺！</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/01/17/Spring源码持续学习-一/">Spring源码持续学习(一)</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">smartcong007</a></p>
        <p><span>发布时间:</span>2018-01-17, 14:25:20</p>
        <p><span>最后更新:</span>2018-01-23, 15:20:09</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/01/17/Spring源码持续学习-一/" title="Spring源码持续学习(一)">http://yoursite.com/2018/01/17/Spring源码持续学习-一/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2018/01/17/Spring源码持续学习-一/　　作者: smartcong007" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/01/24/Spring源码持续学习-二/">
                    Spring源码持续学习(二)
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/12/24/JAVA-oncurrent包学习总结/">
                    JAVA oncurrent包学习总结
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC容器的初始化"><span class="toc-number">1.</span> <span class="toc-text"><a href="#IOC&#x5BB9;&#x5668;&#x7684;&#x521D;&#x59CB;&#x5316;" class="headerlink" title="IOC&#x5BB9;&#x5668;&#x7684;&#x521D;&#x59CB;&#x5316;"></a>IOC&#x5BB9;&#x5668;&#x7684;&#x521D;&#x59CB;&#x5316;</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    

    
        <div class="addthis_sharing_toolbox"></div>
    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/01/24/Spring源码持续学习-二/" title="上一篇: Spring源码持续学习(二)">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/12/24/JAVA-oncurrent包学习总结/" title="下一篇: JAVA oncurrent包学习总结">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/24/Spring源码持续学习-二/">Spring源码持续学习(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/17/Spring源码持续学习-一/">Spring源码持续学习(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/24/JAVA-oncurrent包学习总结/">JAVA oncurrent包学习总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/浅析zookeeper的典型应用场景/">浅析zookeeper的典型应用场景</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 smartcong007
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>