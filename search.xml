<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Spring源码持续学习(二)]]></title>
      <url>/2018/01/24/Spring%E6%BA%90%E7%A0%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>上一篇已经分析了ioc容器的整个初始化的过程，整个初始化完成后，应用也就随时可以从容器中获取实例化bean了。一般容器中的bean默认是单例模式的，也就是在第一次被请求获取时进行实例化，然后就缓存起来可以复用了。这里就详细分析整个实例化过程。</p>
<p>先接上篇文章中最开始的两行示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);</span><br><span class="line">UserService userService = (UserService) context.getBean(&quot;userService&quot;,UserService.class);</span><br></pre></td></tr></table></figure></p>
<p>第一行的实质是整个Ioc容器的初始化过程，那么第二行就是从容器中实例化一个bean的过程了。从genBean()方法我们最终可以进入到AbstractBeanFactory的getBean()方法，所以直接从此处开始分析:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">        return this.doGetBean(name, requiredType, (Object[])null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到具体的实现要到另一个方法doGetBean()中，转向该方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; T doGetBean(String name, Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line">        //如果传入的bean的name是别名的话需要通过该方法转化成bean真实的name</span><br><span class="line">        final String beanName = this.transformedBeanName(name);</span><br><span class="line">        //首先尝试从缓存中获取bean（针对单例bean）</span><br><span class="line">        Object sharedInstance = this.getSingleton(beanName);</span><br><span class="line">        Object bean;</span><br><span class="line">       </span><br><span class="line">        if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">            if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                if (this.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                    this.logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    this.logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);</span><br><span class="line">        &#125; else &#123; //缓存中不存在则要从头开始装配bean</span><br><span class="line">            //避免bean重复创建</span><br><span class="line">            if (this.isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //在有上层BeanFactory情况下，整个过程类似双亲委派机制，尝试迭代委托给上层BeanFactory产生bean</span><br><span class="line">            BeanFactory parentBeanFactory = this.getParentBeanFactory();</span><br><span class="line">            if (parentBeanFactory != null &amp;&amp; !this.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                String nameToLookup = this.originalBeanName(name);</span><br><span class="line">                if (args != null) &#123;</span><br><span class="line">                    return parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!typeCheckOnly) &#123;</span><br><span class="line">                this.markBeanAsCreated(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //没有上层BeanFactory的情况下生产目标Bean</span><br><span class="line">            try &#123;</span><br><span class="line">                //通过从容器中获取的BeanDefinition生成bean</span><br><span class="line">                final RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                this.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">                //装配目标bean之前需要先注册其依赖的所有bean</span><br><span class="line">                String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">                String[] var11;</span><br><span class="line">                if (dependsOn != null) &#123;</span><br><span class="line">                    var11 = dependsOn;</span><br><span class="line">                    int var12 = dependsOn.length;</span><br><span class="line"></span><br><span class="line">                    for(int var13 = 0; var13 &lt; var12; ++var13) &#123;</span><br><span class="line">                        String dep = var11[var13];</span><br><span class="line">                        if (this.isDependent(beanName, dep)) &#123;</span><br><span class="line">                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between &apos;&quot; + beanName + &quot;&apos; and &apos;&quot; + dep + &quot;&apos;&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        this.registerDependentBean(dep, beanName);</span><br><span class="line"></span><br><span class="line">                        try &#123;</span><br><span class="line">                            this.getBean(dep);</span><br><span class="line">                        &#125; catch (NoSuchBeanDefinitionException var24) &#123;</span><br><span class="line">                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;&apos;&quot; + beanName + &quot;&apos; depends on missing bean &apos;&quot; + dep + &quot;&apos;&quot;, var24);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //根据bean的类型用不同的方法创建bean</span><br><span class="line">                if (mbd.isSingleton()) &#123;</span><br><span class="line">                    sharedInstance = this.getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object getObject() throws BeansException &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                return AbstractBeanFactory.this.createBean(beanName, mbd, args);</span><br><span class="line">                            &#125; catch (BeansException var2) &#123;</span><br><span class="line">                                AbstractBeanFactory.this.destroySingleton(beanName);</span><br><span class="line">                                throw var2;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">                &#125; else if (mbd.isPrototype()) &#123;</span><br><span class="line">                    var11 = null;</span><br><span class="line"></span><br><span class="line">                    Object prototypeInstance;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        this.beforePrototypeCreation(beanName);</span><br><span class="line">                        prototypeInstance = this.createBean(beanName, mbd, args);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        this.afterPrototypeCreation(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    bean = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    String scopeName = mbd.getScope();</span><br><span class="line">                    Scope scope = (Scope)this.scopes.get(scopeName);</span><br><span class="line">                    if (scope == null) &#123;</span><br><span class="line">                        throw new IllegalStateException(&quot;No Scope registered for scope name &apos;&quot; + scopeName + &quot;&apos;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                            public Object getObject() throws BeansException &#123;</span><br><span class="line">                                AbstractBeanFactory.this.beforePrototypeCreation(beanName);</span><br><span class="line"></span><br><span class="line">                                Object var1;</span><br><span class="line">                                try &#123;</span><br><span class="line">                                    var1 = AbstractBeanFactory.this.createBean(beanName, mbd, args);</span><br><span class="line">                                &#125; finally &#123;</span><br><span class="line">                                    AbstractBeanFactory.this.afterPrototypeCreation(beanName);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                return var1;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        bean = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                    &#125; catch (IllegalStateException var23) &#123;</span><br><span class="line">                        throw new BeanCreationException(beanName, &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, var23);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (BeansException var26) &#123;</span><br><span class="line">                this.cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">                throw var26;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果在使用Bean时声明的类型跟实例化成的bean的实际类型不一致则需要强制转换</span><br><span class="line">        if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return this.getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            &#125; catch (TypeMismatchException var25) &#123;</span><br><span class="line">                if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                    this.logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type &apos;&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;&apos;&quot;, var25);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return bean;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个过程非常长，关键步骤都已在代码中注释说明。这些步骤需要展开来分析。<br>第一步是尝试从缓存中获取bean,主要针对单例类的bean。需要说明的是spring中对bean的缓存有三级，如下：</p>
<ul>
<li>singletonObjects</li>
<li>earlySingletonObjects</li>
<li>singletonFactories</li>
</ul>
<p>第一级缓存的是那些已经被彻底创建完的bean，第二级是用于缓存尚未创建完成但提前暴露引用的bean，第三级用于缓存提前暴露的bean对应的bean工厂。<br>这里重点分析第二、三级，这两级涉及到spring解决循环依赖的策略。首先有一个singletonsCurrentlyInCreation用于记录那些正处于创建过程中的bean。spring从缓存中取bean的代码片段如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">        //试图从singletonObjects获取缓存的bean</span><br><span class="line">        Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">        if (singletonObject == null &amp;&amp; this.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        //如果从singletonObjects获取失败且检测到bean处于创建中则尝试从earlySingletonObjects中获取bean</span><br><span class="line">            Map var4 = this.singletonObjects;</span><br><span class="line">            synchronized(this.singletonObjects) &#123;</span><br><span class="line">                singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">                //如果从earlySingletonObjects也获取失败且允许获取提前暴露的Bean则尝试从singletonFactories获取</span><br><span class="line">                if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                    //singletonFactories中存的是产生bean的工厂实例，利用从中获取到bean工厂实例后可以生成bean</span><br><span class="line">                    ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName);</span><br><span class="line">                    if (singletonFactory != null) &#123;</span><br><span class="line">                        singletonObject = singletonFactory.getObject();</span><br><span class="line">                        //要将生成的bean回存到earlySingletonObjects中</span><br><span class="line">                        this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        //避免重复生成Bean，从singletonFactories中移除相应工厂实例</span><br><span class="line">                        this.singletonFactories.remove(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return singletonObject != NULL_OBJECT ? singletonObject : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如代码所见，spring正是按顺序从多级缓存中尝试获取Bean，任何一级成功获取则立即返回。首先从singletonObjects中取，这里面主要取那些已经完全创建完成的bean。如果取不到则先检测当前bean是否存在于singletonsCurrentlyInCreation，只有确定bean处于正在创建的状态才会再去二、三级中去取。然后先在earlySingletonObjects中取，如果也取不到。则到singletonFactories中取，注意singletonFactories中存的不是直接的bean的引用，而是ObjectFactory,它是一个函数式接口，里面有一个工厂方法getObject()方法用于返回bean的引用，不同的bean可以有不同的实现，主要是考虑到那些需要代理的bean不能直接返回bean的直接引用。然后通过这个工厂方法返回的bean会被回存到二级缓存中，同时从三级缓存中清除自身。这样一来以后就可以直接从二级缓存中获取到bean的引用而不用再重复调用工厂方法。<br>这里有一个问题，既然只有处在创建中的bean才会去二、三级缓存中取，那么什么情况下才会出现获取bean时发现bean又处于创建中呢？很明显是在循环依赖的情况下才会产生这种情况下，典型的例子是A在初始化时发现属性中有对B的依赖，然后就去创建B，然后初始化B时又发现它对A有依赖，所以再去尝试获取A结果发现A处于创建中。Spring中bean的初始化分三步：</p>
<ul>
<li>createBeanInstance， 实例化，实际上就是调用对应的构造方法构造对象，此时只是调用了构造方法，spring xml中指定的property并没有进行populate</li>
<li>populateBean，填充属性，这步对spring xml中指定的property进行populate</li>
<li>initializeBean，调用spring xml中指定的init方法，或者AfterPropertiesSet方法</li>
</ul>
<p>会发生循环依赖的步骤集中在第一步和第二步，在执行完bean的构造函数后，容器会提前暴露这个bean的引用，以防止在尚未创建完成时被其它bean引用。所以spring无法自动解决构造函数中的循环依赖，因为在构造函数执行过程中bean的引用还未提前暴露。所以只有属性注入时发生的循环依赖才能解决。而且最重要的一点，只有单例的Bean才支持循环引用，因为容器的缓存机制只针对单例的Bean。</p>
<p>如果第一步从缓存中获取bean失败，那么判断当前Bean是否是处在创建过程中的prototype的bean，如果是则抛出BeanCurrentlyInCreationException异常表示无法处理原型Bean的循环依赖。否则进入第二步。</p>
<p>第二步大致分为以下几个部分：</p>
<ul>
<li>首先判断如果当前容器中不存在待获取的bean对应的BeanDefinition则尝试用父工厂来加载bean，否则执行下面部分。</li>
<li>先执行Bean的所有依赖的初始化工作</li>
<li>创建bean的示例</li>
<li>对已经成功创建的示例进行类型检查</li>
</ul>
<p>由于bean的创建的前提是容器中已经加载了bean对应的BeanDefinition，所以先对BeanDefinition进行检查，如果不存在则只能尝试从父工厂中加载bean。<br>如果容器中已经存在BeanDefinition了则执行创建Bean的逻辑，首先加载bean的所有依赖，加载过程中也会检查循环依赖的情况。之后会根据bean的类型执行不同<br>的加载逻辑。对于单例bean，需要调用DefaultSingletonBeanRegistry.getSingleton方法获取实例，该方法有两个参数，一个是bean的name，另外一个参数<br>是一个ObjectFactory接口的实例，ObjectFactory实例提供了getObject方法用于创建并返回bean。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;</span><br><span class="line">		Assert.notNull(beanName, &quot;&apos;beanName&apos; must not be null&quot;);</span><br><span class="line">		synchronized (this.singletonObjects) &#123;</span><br><span class="line">		  //先依然尝试从缓存中取</span><br><span class="line">			Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">			if (singletonObject == null) &#123;</span><br><span class="line">			  //如果工厂正在执行bean的销毁操作则拒绝从中获取Bean</span><br><span class="line">				if (this.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">					throw new BeanCreationNotAllowedException(beanName,</span><br><span class="line">							&quot;Singleton bean creation not allowed while the singletons of this factory are in destruction &quot; +</span><br><span class="line">							&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;Creating shared instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				//作好bean正在创建的标记工作</span><br><span class="line">				beforeSingletonCreation(beanName);</span><br><span class="line">				boolean newSingleton = false;</span><br><span class="line">				boolean recordSuppressedExceptions = (this.suppressedExceptions == null);</span><br><span class="line">				if (recordSuppressedExceptions) &#123;</span><br><span class="line">					this.suppressedExceptions = new LinkedHashSet&lt;Exception&gt;();</span><br><span class="line">				&#125;</span><br><span class="line">				try &#123;</span><br><span class="line">				  //通过传入的工厂实例产生bean实例</span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					newSingleton = true;</span><br><span class="line">				&#125;</span><br><span class="line">				catch (IllegalStateException ex) &#123;</span><br><span class="line">					// Has the singleton object implicitly appeared in the meantime -&gt;</span><br><span class="line">					// if yes, proceed with it since the exception indicates that state.</span><br><span class="line">					singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">					if (singletonObject == null) &#123;</span><br><span class="line">						throw ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				catch (BeanCreationException ex) &#123;</span><br><span class="line">					if (recordSuppressedExceptions) &#123;</span><br><span class="line">						for (Exception suppressedException : this.suppressedExceptions) &#123;</span><br><span class="line">							ex.addRelatedCause(suppressedException);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					throw ex;</span><br><span class="line">				&#125;</span><br><span class="line">				finally &#123;</span><br><span class="line">					if (recordSuppressedExceptions) &#123;</span><br><span class="line">						this.suppressedExceptions = null;</span><br><span class="line">					&#125;</span><br><span class="line">					//移除bean正在创建的状态</span><br><span class="line">					afterSingletonCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				if (newSingleton) &#123;</span><br><span class="line">				  //把成功获取到的单例  bean缓存起来</span><br><span class="line">					addSingleton(beanName, singletonObject);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return (singletonObject != NULL_OBJECT ? singletonObject : null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>有几个值得关注的点，首先是获取单例Bean前需要检查当前beanFactory是否正在销毁所有单例bean，如果是则拒绝获取Bean,也就是说不允许从一个正在执行销毁<br>过程的BeanFactory中获取单例bean。然后调用了beforeSingletonCreation方法在检查当前Bean是否在创建中的同时把当前bean标记为正在创建。然后就可以<br>调用传入的ObjectFactory的实例的getObject方法根据bean的name创建并获取bean了。从前面可以看出getObject方法中是调用AbstractBeanFactory.<br>createBean方法创建bean的，但是由于后面创建prototype的bean也会用到这个方法，所以后面再一并看这个方法。创建完成后再调用afterSingletonCreation<br>方法把bean的正在创建标记去除。最后一步是把创建好的bean放到缓存singletonObjects中，并且销毁singletonFactories和earlySingletonObjects这<br>两级缓存该bean的缓存。</p>
<p>经过getSingleton方法成功获取单例bean后，为防止获取到的是工厂bean的实例，需要调用getObjectForBeanInstance进行相应处理得到最终需要的实例。<br>简单来说如果是工厂bean，则需要通过这个工厂bean生成最终的实例返回。如果不是工厂bean则可直接返回。</p>
<p>如果Bean是prototype类型的，则相比于获取单例Bean更为简单，因为原型Bean不涉及缓存。简单来看，先调用beforePrototypeCreation标记当前待创建的<br>bean为正在创建中，然后调用createBean方法获取bean实例，最后调用afterPrototypeCreation移除bean正在创建的标记。最后是调用afterPrototypeCreation<br>最终处理返回。原型Bean和单例bean的创建都是使用的createBean方法，进去看看:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">		//判断需要实例化的bean对应的类是否已通过类加载器加载</span><br><span class="line">		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class="line">			mbdToUse = new RootBeanDefinition(mbd);</span><br><span class="line">			mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Prepare method overrides.</span><br><span class="line">		try &#123;</span><br><span class="line">			mbdToUse.prepareMethodOverrides();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">					beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		  //判断是否配置了后置处理器，如果配置了则返回一个代理</span><br><span class="line">			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">			if (bean != null) &#123;</span><br><span class="line">				return bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">					&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    //创建bean</span><br><span class="line">		Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Finished creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return beanInstance;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中除去前面的检验、准备工作，后面核心的创建bean的方法是doCreateBean方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123;</span><br><span class="line">		// 使用BeanWrapper包装bean实例</span><br><span class="line">		BeanWrapper instanceWrapper = null;</span><br><span class="line">		if (mbd.isSingleton()) &#123;</span><br><span class="line">		  //从缓存中获取并移除由FactoryBean创建的单例bean</span><br><span class="line">			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		if (instanceWrapper == null) &#123;</span><br><span class="line">		  //从缓存中获取失败则直接创建</span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class="line">		Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</span><br><span class="line"></span><br><span class="line">		// 如果配置了后置处理器需要在此时利用它们对BeanDefinition作最后修改</span><br><span class="line">		synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">			if (!mbd.postProcessed) &#123;</span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				mbd.postProcessed = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    //如果是单例bean则暴露bean的引用到缓存中以便于支持循环引用</span><br><span class="line">		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName +</span><br><span class="line">						&quot;&apos; to allow for resolving potential circular references&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public Object getObject() throws BeansException &#123;</span><br><span class="line">					return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 装填bean的属性并调用bean的init方法初始化</span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		try &#123;</span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			if (exposedObject != null) &#123;</span><br><span class="line">				exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">				throw (BeanCreationException) ex;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">			if (earlySingletonReference != null) &#123;</span><br><span class="line">				if (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">					for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								&quot;Bean with name &apos;&quot; + beanName + &quot;&apos; has been injected into other beans [&quot; +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +</span><br><span class="line">								&quot;wrapped. This means that said other beans do not use the final version of the &quot; +</span><br><span class="line">								&quot;bean. This is often the result of over-eager type matching - consider using &quot; +</span><br><span class="line">								&quot;&apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for example.&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//将创建好的bean注册到容器中(prototype类型的Bean则不需要注册)</span><br><span class="line">		try &#123;</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面经历了创建Bean、如果配置了后置处理器对bean作进一步修改、缓存bean以支持循环引用、装填bean的属性以及执行初始化方法(如果有的话)、注册创建好的<br>bean到容器中。先关注创建bean的方法，创建bean是调用的creatBeanInstance方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123;</span><br><span class="line">		// 确保bean对应的Class已经被加载</span><br><span class="line">		Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"> </span><br><span class="line">    /*</span><br><span class="line">     * 检测类的访问权限。默认情况下，对于非 public 的类，是允许访问的。</span><br><span class="line">     * 若禁止访问，这里会抛出异常</span><br><span class="line">     */</span><br><span class="line">		if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">			throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">					&quot;Bean class isn&apos;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">		&#125;</span><br><span class="line">、   //如果bean具有工厂方法，则利用工厂方法创建Bean</span><br><span class="line">		if (mbd.getFactoryMethodName() != null)  &#123;</span><br><span class="line">			return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		boolean resolved = false;</span><br><span class="line">		boolean autowireNecessary = false;</span><br><span class="line">		if (args == null) &#123;</span><br><span class="line">			synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">			  //如果有已经解析过的构造函数的缓存则可以直接用来构造对象，省去构造器的解析步骤</span><br><span class="line">				if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">					resolved = true;</span><br><span class="line">					autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (resolved) &#123;</span><br><span class="line">			if (autowireNecessary) &#123;</span><br><span class="line">			  //通过构造函数自动注入的方式构造bean的实例</span><br><span class="line">				return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">			  //通过默认构造函数构建Bean的对象</span><br><span class="line">				return instantiateBean(beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//由后置处理器解析构建bean实例的所有可选构造器(默认构造器之外的构造器)</span><br><span class="line">		Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">		    /*</span><br><span class="line">         * 下面的条件分支条件用于判断使用什么方式构造 bean 实例，有两种方式可选 - 构造方法自动</span><br><span class="line">         * 注入和默认构造方法。判断的条件由4部分综合而成，如下：</span><br><span class="line">         * </span><br><span class="line">         *    条件1：ctors != null -&gt; 后置处理器返回构造方法数组是否为空</span><br><span class="line">         *    </span><br><span class="line">         *    条件2：mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR </span><br><span class="line">         *              -&gt; bean 配置中的 autowire 属性是否为 constructor    </span><br><span class="line">         *    条件3：mbd.hasConstructorArgumentValues() </span><br><span class="line">         *              -&gt; constructorArgumentValues 是否存在元素，即 bean 配置文件中</span><br><span class="line">         *                 是否配置了 &lt;construct-arg/&gt;</span><br><span class="line">         *    条件4：!ObjectUtils.isEmpty(args) </span><br><span class="line">         *              -&gt; args 数组是否存在元素，args 是由用户调用 </span><br><span class="line">         *                 getBean(String name, Object... args) 传入的</span><br><span class="line">         * </span><br><span class="line">         * 上面4个条件，只要有一个为 true，就会通过构造方法自动注入的方式构造 bean 实例</span><br><span class="line">         */</span><br><span class="line">		if (ctors != null ||</span><br><span class="line">				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">			//通过构造器自动注入构建Bean</span><br><span class="line">			return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 通过默认构造器构建bean</span><br><span class="line">		return instantiateBean(beanName, mbd);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是构建Bean的过程了，先作构建前校验，构建时根据实际情况选择不同的构建策略：如果bean定义有工厂方法，则通过工厂方法构建Bean; 如果缓存中存在<br>bean的已经解析过的构造器，则使用缓存的构造器构建，这里主要针对prototype的bean，这种bean每次使用都会重新创建，在重复创建的过程中，解析构造函数<br>也是重复且耗费性能的工作，所以spring在第一次构建bean时就会把解析好的构造器缓存起来；如果不存在缓存，则需要解析构造器，以决定是使用自定义的构造器<br>还是默认构造器构建bean。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring源码持续学习(一)]]></title>
      <url>/2018/01/17/Spring%E6%BA%90%E7%A0%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0-%E4%B8%80/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Spring一直在用，从早期的直接使用spring到现在工作中使用公司定制版的spring，不管是哪种形式的spring的变种，都是依附于spring本身的特性作一些功能上的定制。要理解到spring本身的一些特性就必须要读其源码，所以干就是了。。。</p>
</blockquote>
<h2 id="IOC容器的初始化"><a href="#IOC容器的初始化" class="headerlink" title="IOC容器的初始化"></a>IOC容器的初始化</h2><p>ioc容器是spring的核心部分，一个基于spring的应用程序的生命周期中一个最重要的过程就是ioc容器的初始化。我们日常使用spring就知道，整个容器的初始化依赖于配置文件的读取和解析。具体展开来说就是以下三个步骤：</p>
<ul>
<li>由ResourceLoader通过统一的Resource接口来定位不同形式的bean配置文件</li>
<li>通过对定位到的resource文件解析得到相应的BeanDefinition，BeanDefinition实质上是外部对象在ioc容器内部对应的数据结构表示。</li>
<li>向Ioc容器中注册已经 解析的BeanDefinition,存放到对应的beanDefinitionMap中</li>
</ul>
<p>而日常工作中我们大多以xml的形式配置spring(虽然早在官方4.0版本就开始推崇java的形式配置spring)，所以在此还是以xml配置文件为例分析配置文件完整的载入、解析过程。</p>
<p>先来看加载xml配置文件的入口部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);</span><br><span class="line">MediaCluesSellCarInfoDao mediaCluesSellCarInfoDao = (MediaCluesSellCarInfoDao) context.getBean(&quot;mediaCluesSellCarInfoDao&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这里是常见的从类路径下读取配置文件，当然还有从整个文件系统，应用下读取配置文件的方法。第一行代码其实就代表整个加载过程的总入口了，只需要从第一行代码进去分析。这里用到了ClassPathXmlApplicationContext的构造函数之一：ClassPathXmlApplicationContext(String configLocation)，进去看这个构造函数发现它其实还是调用了另一个基础的构造函数：ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)。下面进去分析这个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		super(parent);</span><br><span class="line">		setConfigLocations(configLocations);</span><br><span class="line">		if (refresh) &#123;</span><br><span class="line">			refresh();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一行是初始化时配置父容器(最常见的一个配置文件中import了其他配置文件),这里只是单纯的设置一下父ApplicationContext，不用详谈。第二行用于本地记录spring配置文件的路径并初步解析替换配置文件中可能用到的系统占位符。可以进去看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setConfigLocations(String... locations) &#123;</span><br><span class="line">		if (locations != null) &#123;</span><br><span class="line">			Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);</span><br><span class="line">			this.configLocations = new String[locations.length];</span><br><span class="line">			for (int i = 0; i &lt; locations.length; i++) &#123;</span><br><span class="line">				this.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			this.configLocations = null;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到将配置文件进行了一次resolvePath的操作后才转存成相应的path数组，进去瞧瞧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected String resolvePath(String path) &#123;</span><br><span class="line">		return getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到没有，这里对原始路径的配置文件进行了resolveRequiredPlaceholders的操作，看名字就猜得到这个方法就是进行占位符的解析。其实这里只要明白了其用意就可以打住了。接下来可以想象就是把配置文件中的占位符替换成具体的系统环境变量(如：System.dir)的过程。我们退到最初的ClassPathXmlApplicationContext的构造函数中进入最核心的一步：refresh()。也就是整个容器的刷新函数，进去详加分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">		synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">			// Prepare this context for refreshing.</span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			// Prepare the bean factory for use in this context.</span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Invoke factory processors registered as beans in the context.</span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Register bean processors that intercept bean creation.</span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Initialize message source for this context.</span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				// Initialize event multicaster for this context.</span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				// Initialize other special beans in specific context subclasses.</span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				// Check for listener beans and register them.</span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Last step: publish corresponding event.</span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				if (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">							&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				// Reset &apos;active&apos; flag.</span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				// Propagate exception to caller.</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			finally &#123;</span><br><span class="line">				// Reset common introspection caches in Spring&apos;s core, since we</span><br><span class="line">				// might not ever need metadata for singleton beans anymore...</span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以清晰的看到spring将容器的刷新过程分成好几个子步骤来完成，refresh()中调用的每一个子方法对应一个子步骤。这样一来是因为整个refresh操作涉及的东西太多需要分拆解耦，二来是为了增强其扩展性。这里需要耐心地按顺序逐个解析。</p>
<p><em>prepareRefresh</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareRefresh() &#123;</span><br><span class="line">		this.startupDate = System.currentTimeMillis();</span><br><span class="line">		this.closed.set(false);</span><br><span class="line">		this.active.set(true);</span><br><span class="line"></span><br><span class="line">		if (logger.isInfoEnabled()) &#123;</span><br><span class="line">			logger.info(&quot;Refreshing &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Initialize any placeholder property sources in the context environment</span><br><span class="line">		initPropertySources();</span><br><span class="line"></span><br><span class="line">		// Validate that all properties marked as required are resolvable</span><br><span class="line">		// see ConfigurablePropertyResolver#setRequiredProperties</span><br><span class="line">		getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">		// Allow for the collection of early ApplicationEvents,</span><br><span class="line">		// to be published once the multicaster is available...</span><br><span class="line">		this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前三行用于设置一些标志位和上下文刷新的开始时间，initPropertySources()方法从注释可以看出是初始化配置文件中自定义占位符对应的properties信息，默认为空方法可供开发者自行扩展,getEnvironment().validateRequiredProperties()用于校验配置文件中那些必需的属性是否都能解析到。</p>
<p><em>obtainFreshBeanFactory</em><br>第二步就是获取刷新spring上下文的bean工厂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">		refreshBeanFactory();</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line">		return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>核心的还是第一行refreshBeanFactory(),刷新bean工厂，进去看看:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">		if (hasBeanFactory()) &#123;</span><br><span class="line">			destroyBeans();</span><br><span class="line">			closeBeanFactory();</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">			beanFactory.setSerializationId(getId());</span><br><span class="line">			customizeBeanFactory(beanFactory);</span><br><span class="line">			loadBeanDefinitions(beanFactory);</span><br><span class="line">			synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">				this.beanFactory = beanFactory;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到代码中前四行销毁当前已经存在的bean工厂(如果有的话)，后面再新建一个bean工厂，这里可以看出新建的bean工厂是DefaultListableBeanFactory类型的，然后对新的bean工厂作一些初始化工作，初始化中最重要的是loadBeanDefinitions(beanFactory)，进去看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">		// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br><span class="line">		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">		// Configure the bean definition reader with this context&apos;s</span><br><span class="line">		// resource loading environment.</span><br><span class="line">		beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">		beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">		// Allow a subclass to provide custom initialization of the reader,</span><br><span class="line">		// then proceed with actually loading the bean definitions.</span><br><span class="line">		initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">		loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实loadBeanDefinitions有多种实现，取决于bean以何种形式配置，这里bean是以xml文件的形式配置的，自然而然要看AbstractXmlApplicationContext的实现。从代码中可以看出加载bean的信息要用到XmlBeanDefinitionReader实例，所以这里先通过先前初始化的beanFactory实例化一个XmlBeanDefinitionReader，实例化后还用用当前的context的资源加载环境初始化它。最后一行是最核心的一步，进去看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">		Resource[] configResources = getConfigResources();</span><br><span class="line">		if (configResources != null) &#123;</span><br><span class="line">			reader.loadBeanDefinitions(configResources);</span><br><span class="line">		&#125;</span><br><span class="line">		String[] configLocations = getConfigLocations();</span><br><span class="line">		if (configLocations != null) &#123;</span><br><span class="line">			reader.loadBeanDefinitions(configLocations);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里默认情况下其实还是根据配置文件的路径来加载BeanDefinition，因为getConfigResources()进去看是一个空方法，也就是这里留下了一个扩展点，可以通过重写这个方法来提供一些预置的配置源，这样加载BeanDefinition将先从这些预置的配置源加载，然后才是从最开始传入的路径信息加载。接着顺藤摸瓜进入加载单个源文件的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);</span><br><span class="line">        if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">            this.logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;EncodedResource&gt; currentResources = (Set)this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">        if (currentResources == null) &#123;</span><br><span class="line">            currentResources = new HashSet(4);</span><br><span class="line">            this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!((Set)currentResources).add(encodedResource)) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int var5;</span><br><span class="line">            try &#123;</span><br><span class="line">                InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">                    if (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">                        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    var5 = this.doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException var15) &#123;</span><br><span class="line">                throw new BeanDefinitionStoreException(&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), var15);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                ((Set)currentResources).remove(encodedResource);</span><br><span class="line">                if (((Set)currentResources).isEmpty()) &#123;</span><br><span class="line">                    this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return var5;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在进入这个方法之前其实省略了一些部分，其实重点就是作了从location得到EncodedResource的过程，不是关注的重点不用在意。接着看这段代码，其实这段代码的重点可以总结为先把EncodedResource转化成InputSource，因为用SAX API读取xml文件使都要从InputSource开始，然后进入doLoadBeanDefinitions(inputSource, encodedResource.getResource())：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Document doc = this.doLoadDocument(inputSource, resource);</span><br><span class="line">return this.registerBeanDefinitions(doc, resource);</span><br></pre></td></tr></table></figure></p>
<p>这里为了节省篇幅只截取关键的两行代码，第一行就是通过前面的的InputSource和Resource对象生成一个Document对象，Document对象是java中处理xml文件的基础对象，Document对象中就包含了xml文件中对应的所有节点信息。进第二行继续看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        BeanDefinitionDocumentReader documentReader = this.createBeanDefinitionDocumentReader();</span><br><span class="line">        int countBefore = this.getRegistry().getBeanDefinitionCount();</span><br><span class="line">        documentReader.registerBeanDefinitions(doc, this.createReaderContext(resource));</span><br><span class="line">        return this.getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过BeanDefinitionDocumentReader来从Document中读取bean信息并注册成为最终的BeanDefinition，继续看registerBeanDefinitions方法直接进入doRegisterBeanDefinitions方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">        BeanDefinitionParserDelegate parent = this.delegate;</span><br><span class="line">        this.delegate = this.createDelegate(this.getReaderContext(), root, parent);</span><br><span class="line">        if (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            String profileSpec = root.getAttribute(&quot;profile&quot;);</span><br><span class="line">            if (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, &quot;,; &quot;);</span><br><span class="line">                if (!this.getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">                        this.logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + this.getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.preProcessXml(root);</span><br><span class="line">        this.parseBeanDefinitions(root, this.delegate);</span><br><span class="line">        this.postProcessXml(root);</span><br><span class="line">        this.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的root是前面的Doucument的根节点元素,可以看到这里对Doucument的解析依赖于一个委托类BeanDefinitionParserDelegate，默认BeanDefinitionParserDelegate会处理<a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a>命名空间下元素及其属性,查看源码可以看到BeanDefinitionParserDelegate下面定义了一堆元素和属性名称,这些元素和属性名称分别可以在类中找到处理方法.然后进入parseBeanDefinitions方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            NodeList nl = root.getChildNodes();</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; nl.getLength(); ++i) &#123;</span><br><span class="line">                Node node = nl.item(i);</span><br><span class="line">                if (node instanceof Element) &#123;</span><br><span class="line">                    Element ele = (Element)node;</span><br><span class="line">                    if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                        this.parseDefaultElement(ele, delegate);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        delegate.parseCustomElement(ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            delegate.parseCustomElement(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这儿有一点比较麻烦，就是解析默认命名空间下的标签(如bean,import,beans,alias)和其它命名空间下的标签(如aop、jdbc,context:component-scan等)是分开的，先看解析默认标签parseDefaultElement:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        if (delegate.nodeNameEquals(ele, &quot;import&quot;)) &#123;</span><br><span class="line">            this.importBeanDefinitionResource(ele);</span><br><span class="line">        &#125; else if (delegate.nodeNameEquals(ele, &quot;alias&quot;)) &#123;</span><br><span class="line">            this.processAliasRegistration(ele);</span><br><span class="line">        &#125; else if (delegate.nodeNameEquals(ele, &quot;bean&quot;)) &#123;</span><br><span class="line">            this.processBeanDefinition(ele, delegate);</span><br><span class="line">        &#125; else if (delegate.nodeNameEquals(ele, &quot;beans&quot;)) &#123;</span><br><span class="line">            this.doRegisterBeanDefinitions(ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清晰地看到针对不同的标签分别调用相应的处理方法，这里重点看一下对<bean>的处理processBeanDefinition:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">        if (bdHolder != null) &#123;</span><br><span class="line">            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry());</span><br><span class="line">            &#125; catch (BeanDefinitionStoreException var5) &#123;</span><br><span class="line">                this.getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></bean></p>
<p>重点是第一行代码解析bean标签并生成BeanDefinitionHolder，后面就是把生成的BeanDefinitionHolder注册到DefaultListableBeanFactory的beanDefinitionMap中。进入parseBeanDefinitionElement看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class="line">        String id = ele.getAttribute(&quot;id&quot;);</span><br><span class="line">        String nameAttr = ele.getAttribute(&quot;name&quot;);</span><br><span class="line">        List&lt;String&gt; aliases = new ArrayList();</span><br><span class="line">        if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, &quot;,; &quot;);</span><br><span class="line">            aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String beanName = id;</span><br><span class="line">        if (!StringUtils.hasText(id) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            beanName = (String)aliases.remove(0);</span><br><span class="line">            if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                this.logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName + &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (containingBean == null) &#123;</span><br><span class="line">            this.checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbstractBeanDefinition beanDefinition = this.parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">        if (beanDefinition != null) &#123;</span><br><span class="line">            if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (containingBean != null) &#123;</span><br><span class="line">                        beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                        String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                        if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                            aliases.add(beanClassName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                        this.logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception var9) &#123;</span><br><span class="line">                    this.error(var9.getMessage(), ele);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">            return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码首先给这个Element对应的bean起名字，然后生成相应的BeanDefinition，最后将生成的BeanDefinition包装成BeanDefinitionHolder。第一步值得注意的一点是获取bean的名字时是优先选用id作为名字，如果bean没有指定id则利用name来生成名字。接下来看关键一步parseBeanDefinitionElement：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line">        this.parseState.push(new BeanEntry(beanName));</span><br><span class="line">        String className = null;</span><br><span class="line">        if (ele.hasAttribute(&quot;class&quot;)) &#123;</span><br><span class="line">            className = ele.getAttribute(&quot;class&quot;).trim();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            String parent = null;</span><br><span class="line">            if (ele.hasAttribute(&quot;parent&quot;)) &#123;</span><br><span class="line">                parent = ele.getAttribute(&quot;parent&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbstractBeanDefinition bd = this.createBeanDefinition(className, parent);</span><br><span class="line">            this.parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">            bd.setDescription(DomUtils.getChildElementValueByTagName(ele, &quot;description&quot;));</span><br><span class="line">            this.parseMetaElements(ele, bd);</span><br><span class="line">            this.parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">            this.parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">            this.parseConstructorArgElements(ele, bd);</span><br><span class="line">            this.parsePropertyElements(ele, bd);</span><br><span class="line">            this.parseQualifierElements(ele, bd);</span><br><span class="line">            bd.setResource(this.readerContext.getResource());</span><br><span class="line">            bd.setSource(this.extractSource(ele));</span><br><span class="line">            AbstractBeanDefinition var7 = bd;</span><br><span class="line">            return var7;</span><br><span class="line">        &#125; catch (ClassNotFoundException var13) &#123;</span><br><span class="line">            this.error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, var13);</span><br><span class="line">        &#125; catch (NoClassDefFoundError var14) &#123;</span><br><span class="line">            this.error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, var14);</span><br><span class="line">        &#125; catch (Throwable var15) &#123;</span><br><span class="line">            this.error(&quot;Unexpected failure during bean definition parsing&quot;, ele, var15);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            this.parseState.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以清晰地看到做的事儿就是解析bean标签的各种属性。这里先利用element的className和parent属性生成AbstractBeanDefinition的实例bd，然后调用parseBeanDefinitionAttributes方法继续获取element的scope、lazy-init、abstract、depends-on属性等等并设置到bd中，最后还要解析element的构造参数，meta，lookup-method等一系列跟bean初始化相关的属性到bd中，然后就返回了element解析来的完整的BeanDefinition了。最后回到上一步的parseBeanDefinitionElement方法中用包装类BeanDefinitionHolder将BeanDefinition包装一下，最后回到processBeanDefinition中注册BeanDefinition到DefaultListableBeanFactory的beanDefinitionMap中。</p>
<p>接下来说说非默认命名空间下的元素的解析，对非默认命名空间下元素的解析依赖于一个委托类BeanDefinitionParserDelegate的parseCustomElement方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123;</span><br><span class="line">        String namespaceUri = this.getNamespaceURI(ele);</span><br><span class="line">        NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">        if (handler == null) &#123;</span><br><span class="line">            this.error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从以上代码可以看出是先根据元素找到匹配的命名空间namespaceUri（例如<a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a>，哈哈现在知道xml文件最开头的元素前缀与命名空间的映射声明有何卵用了），然后用这个namespaceUri找到对应的NamespaceHandler实例，然后调用NamespaceHandler对应的parse方法来处理对应元素。比如”<context:component-scan>“最终得到的是ContextNameSpaceHandler。对命名空间的解析主要是这一句this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri)，先获取当前xmlReaderContext下的NamespaceHandlerResolver，然后调用对应的resolve方法，看一下这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public NamespaceHandler resolve(String namespaceUri) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; handlerMappings = this.getHandlerMappings();</span><br><span class="line">        Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">        if (handlerOrClassName == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123;</span><br><span class="line">            return (NamespaceHandler)handlerOrClassName;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String className = (String)handlerOrClassName;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader);</span><br><span class="line">                if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">                    throw new FatalBeanException(&quot;Class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri + &quot;] does not implement the [&quot; + NamespaceHandler.class.getName() + &quot;] interface&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    NamespaceHandler namespaceHandler = (NamespaceHandler)BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">                    namespaceHandler.init();</span><br><span class="line">                    handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">                    return namespaceHandler;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException var7) &#123;</span><br><span class="line">                throw new FatalBeanException(&quot;NamespaceHandler class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri + &quot;] not found&quot;, var7);</span><br><span class="line">            &#125; catch (LinkageError var8) &#123;</span><br><span class="line">                throw new FatalBeanException(&quot;Invalid NamespaceHandler class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri + &quot;]: problem with handler class file or dependent class&quot;, var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></context:component-scan></p>
<p>以上代码中先得到一个命名空间与命名空间对应解析类的映射Map,怎么得到的还要看getHandlerMappings():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Object&gt; getHandlerMappings() &#123;</span><br><span class="line">        if (this.handlerMappings == null) &#123;</span><br><span class="line">            synchronized(this) &#123;</span><br><span class="line">                if (this.handlerMappings == null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);</span><br><span class="line">                        if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            this.logger.debug(&quot;Loaded NamespaceHandler mappings: &quot; + mappings);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Map&lt;String, Object&gt; handlerMappings = new ConcurrentHashMap(mappings.size());</span><br><span class="line">                        CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);</span><br><span class="line">                        this.handlerMappings = handlerMappings;</span><br><span class="line">                    &#125; catch (IOException var5) &#123;</span><br><span class="line">                        throw new IllegalStateException(&quot;Unable to load NamespaceHandler mappings from location [&quot; + this.handlerMappingsLocation + &quot;]&quot;, var5);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this.handlerMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码不复杂，大致意思是先从指定位置读取Properties配置文件，这个指定位置其实是NamespaceHandlerResolver在初始化时就指定好了的，在代码的第一行public static final String DEFAULT_HANDLER_MAPPINGS_LOCATION = “META-INF/spring.handlers”;也就是去类路径下加载所有META-INF下的spring.handlers，例如我们可以找到spring-context jar包下的META-INF/spring.handlers文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</span><br></pre></td></tr></table></figure></p>
<p>显然可以想到在上面resolve()一开始获取的handlerMappings就是各个Jar包下的spring.handlers文件转换来的，继续看resolve()接下来做的事：从handlerMappings中根据命名空间地址获取对应的命名空间解析类，如果这个解析类已经是NamespaceHandler类型的则直接返回，否则根据这个解析类的类名强制重新加载NamespaceHandler类型的类并返回，这样下来最初的<a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a>最终就被解析成了ContextNamespaceHandler类。然后看ContextNamespaceHandler中的parse():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">        return this.findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对不起，即使到了ContextNamespaceHandler下还是不能直接解析标签，因为大家都知道挂在<a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a>命名空间下的标签不止一个，还有多个，我们可以看ContextNamespaceHandler的init方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void init() &#123;</span><br><span class="line">		registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到了吧，不止一个 <context:component-scan> ,还有如 <context:property-placeholder> 等7个标签。所以ContextNamespaceHandler的parse方法需要先根据标签名得到对应的BeanDefinitionParser对象，也就是this.findParserForElement(element, parserContext)。例如component-scan得到的是ComponentScanBeanDefinitionParser。最后调用Parse类中的parse()对元素解析，例如我们看ComponentScanBeanDefinitionParser:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   private static final String BASE_PACKAGE_ATTRIBUTE = &quot;base-package&quot;;</span><br><span class="line"></span><br><span class="line">private static final String RESOURCE_PATTERN_ATTRIBUTE = &quot;resource-pattern&quot;;</span><br><span class="line"></span><br><span class="line">private static final String USE_DEFAULT_FILTERS_ATTRIBUTE = &quot;use-default-filters&quot;;</span><br><span class="line"></span><br><span class="line">private static final String ANNOTATION_CONFIG_ATTRIBUTE = &quot;annotation-config&quot;;</span><br><span class="line"></span><br><span class="line">private static final String NAME_GENERATOR_ATTRIBUTE = &quot;name-generator&quot;;</span><br><span class="line"></span><br><span class="line">private static final String SCOPE_RESOLVER_ATTRIBUTE = &quot;scope-resolver&quot;;</span><br><span class="line"></span><br><span class="line">private static final String SCOPED_PROXY_ATTRIBUTE = &quot;scoped-proxy&quot;;</span><br><span class="line"></span><br><span class="line">private static final String EXCLUDE_FILTER_ELEMENT = &quot;exclude-filter&quot;;</span><br><span class="line"></span><br><span class="line">private static final String INCLUDE_FILTER_ELEMENT = &quot;include-filter&quot;;</span><br><span class="line"></span><br><span class="line">private static final String FILTER_TYPE_ATTRIBUTE = &quot;type&quot;;</span><br><span class="line"></span><br><span class="line">private static final String FILTER_EXPRESSION_ATTRIBUTE = &quot;expression&quot;;</span><br></pre></td></tr></table></figure></context:property-placeholder></context:component-scan></p>
<p>看到没有，ComponentScanBeanDefinitionParser类的属性就包含了<comtext:component:scan>的所有属性，例如常见的base-package。然后ComponentScanBeanDefinitionParser包含了相应的parse()去解析标签并直接注册到context中。</comtext:component:scan></p>
<p>这一篇分析下来头皮发麻，顺藤摸瓜式的读源码是一种享受吧☺！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA oncurrent包学习总结]]></title>
      <url>/2017/12/24/JAVA-oncurrent%E5%8C%85%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>concurrent包是java中专门用来处理并发的包，并发编程的基础便是对这个包下的常用api的熟练使用。由于并发场景的复杂和多样性，常常会有<br>  很多不同的并发手段。此文对常见的并发api进行梳理。</p>
</blockquote>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>java中有阻塞队列的各种不同实现，都是实现自BlockingQueue接口，包含：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<p>BlockingQueue接口中有一组通用的方法对比如下，一般使用频率最高的是阻塞方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(o)</td>
<td>offer(o)</td>
<td>put(o)</td>
<td>offer(o,timeout,timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove(o)</td>
<td>poll(o)</td>
<td>take(o)</td>
<td>poll(timeout,timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>element(o)</td>
<td>peek(o) </td>
</tr>
</tbody>
</table>
<p>四组不同的行为方式解释：</p>
<p><strong>抛异常</strong>：如果试图的操作无法立即执行，抛一个异常。</p>
<p><strong>特定值</strong>：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</p>
<p><strong>阻塞</strong>：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</p>
<p><strong>超时</strong>：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>数组阻塞队列是一个有界的阻塞队列，内部实现是将对象放到一个数组中。它有一个同一时间能存储元素数量的上限。其内部对元素采用FIFO的顺序存储元素，即队列头部放置的是放入时间最久的元素，底部放置最新放入的元素。<br>简单实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue queue = new ArrayBlockingQueue(1024);  </span><br><span class="line">queue.put(&quot;1&quot;);  </span><br><span class="line">Object object = queue.take();</span><br></pre></td></tr></table></figure>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>延迟队列中的元素都有一个特定的延迟时间来确定其过期时间，如果未到达其过期时间对该元素调用take()将阻塞，到达过期时间后调用take()才能移除元素。阻塞队列中的元素都要实现Delayed接口。具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class Item&lt;T&gt; implements Delayed &#123;</span><br><span class="line">	</span><br><span class="line">	    private static final long NANO_ORIGIN = System.nanoTime();</span><br><span class="line">	</span><br><span class="line">	    private static final AtomicLong sequencer = new AtomicLong(0);</span><br><span class="line">	</span><br><span class="line">	    private final long sequenceNumber;</span><br><span class="line">	</span><br><span class="line">	    private final long time;</span><br><span class="line">	</span><br><span class="line">	    private final T content;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	    public Item(T content,long timeout)&#123;</span><br><span class="line">	</span><br><span class="line">	        this.content = content;</span><br><span class="line">	        this.time = now()+timeout;</span><br><span class="line">	        this.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">	</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    final static long now()&#123;</span><br><span class="line">	        return System.nanoTime() - NANO_ORIGIN;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	    @Override</span><br><span class="line">	    public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">	</span><br><span class="line">	        long d = unit.convert(time-now(),TimeUnit.NANOSECONDS);</span><br><span class="line">	        return d;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    @Override</span><br><span class="line">	    public int compareTo(Delayed o) &#123;</span><br><span class="line">	</span><br><span class="line">	        if (o == this)&#123;</span><br><span class="line">	            return 0;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        if(o instanceof Item)&#123;</span><br><span class="line">	            Item i = (Item) o;</span><br><span class="line">	            long con = time-i.time;</span><br><span class="line">	            if (con&lt;0) return -1;</span><br><span class="line">	            else if(con&gt;0) return 1;</span><br><span class="line">	            else if(sequenceNumber&lt;i.sequenceNumber) return -1;</span><br><span class="line">	            else return 1;</span><br><span class="line">	</span><br><span class="line">	        &#125;</span><br><span class="line">	        long d = (getDelay(TimeUnit.NANOSECONDS)-o.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">	        return d==0?0:((d &lt; 0) ? -1 : 1);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    public T getContent() &#123;</span><br><span class="line">	        return content;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">		 </span><br><span class="line">	ConcurrentTest.class:</span><br><span class="line">	</span><br><span class="line">	package com.cong.test;</span><br><span class="line">	</span><br><span class="line">	import java.util.concurrent.DelayQueue;</span><br><span class="line">	import java.util.concurrent.TimeUnit;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * Created by zhengcong on 2017/9/13.</span><br><span class="line">	 */</span><br><span class="line">	public class ConcurrentTest &#123;</span><br><span class="line">	</span><br><span class="line">	    private static DelayQueue&lt;Item&lt;String&gt;&gt; delayQueue = new DelayQueue&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	</span><br><span class="line">	        delayQueue.add(new Item(&quot;zheng&quot;, TimeUnit.NANOSECONDS.convert(6, TimeUnit.SECONDS)));</span><br><span class="line">	        Item&lt;String&gt; item;</span><br><span class="line">	        item = delayQueue.take();</span><br><span class="line">	        if (item != null) &#123;</span><br><span class="line">	            System.out.println(item.getContent());</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>内部以链式结构存储元素，如不指定上限，将以Integer.MAX_VALUE作为上限，采用FIFO的方式存储元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; unbounded = new LinkedBlockingQueue&lt;String&gt;();  </span><br><span class="line">BlockingQueue&lt;String&gt; bounded   = new LinkedBlockingQueue&lt;String&gt;(1024);  </span><br><span class="line">bounded.put(&quot;Value&quot;);  </span><br><span class="line">String value = bounded.take();</span><br></pre></td></tr></table></figure></p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>优先阻塞队列，队列中的元素必须实现java.lang.Comparable接口，由元素具体的compare()的具体实现决定了元素在队列中的存储顺序。注意：如果用Iterator对其进行枚举并不能保证它对元素的遍历是以优先级为序的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class TestPriorityQueue &#123;  </span><br><span class="line">	   </span><br><span class="line">	    static Random r=new Random(47);  </span><br><span class="line">	      </span><br><span class="line">	    public static void main(String args[]) throws InterruptedException&#123;  </span><br><span class="line">	        final PriorityBlockingQueue q=new PriorityBlockingQueue();  </span><br><span class="line">	        ExecutorService se=Executors.newCachedThreadPool();  </span><br><span class="line">	        //execute producer  </span><br><span class="line">	        se.execute(new Runnable()&#123;  </span><br><span class="line">	            public void run() &#123;  </span><br><span class="line">	                int i=0;  </span><br><span class="line">	                while(true)&#123;  </span><br><span class="line">	                    q.put(new PriorityEntity(r.nextInt(10),i++));  </span><br><span class="line">	                    try &#123;  igitggggd</span><br><span class="line">	                        TimeUnit.MILLISECONDS.sleep(r.nextInt(1000));  </span><br><span class="line">	                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	                        // TODO Auto-generated catch block  </span><br><span class="line">	                        e.printStackTrace();  </span><br><span class="line">	                    &#125;  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;); </span><br><span class="line">	          </span><br><span class="line">	        //execute consumer  </span><br><span class="line">	        se.execute(new Runnable()&#123;  </span><br><span class="line">	            public void run() &#123;  </span><br><span class="line">	                while(true)&#123;  </span><br><span class="line">	                    try &#123;  </span><br><span class="line">	                        System.out.println(&quot;take-- &quot;+q.take()+&quot; left:-- [&quot;+q.toString()+&quot;]&quot;);  </span><br><span class="line">	                        try &#123;  </span><br><span class="line">	                            TimeUnit.MILLISECONDS.sleep(r.nextInt(1000));  </span><br><span class="line">	                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	                            // TODO Auto-generated catch block  </span><br><span class="line">	                            e.printStackTrace();  </span><br><span class="line">	                        &#125;  </span><br><span class="line">	                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	                        e.printStackTrace();  </span><br><span class="line">	                    &#125;  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;);  </span><br><span class="line">	        try &#123;  </span><br><span class="line">	            TimeUnit.SECONDS.sleep(5);  </span><br><span class="line">	        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	            // TODO Auto-generated catch block  </span><br><span class="line">	            e.printStackTrace();  </span><br><span class="line">	        &#125;  </span><br><span class="line">	        System.out.println(&quot;shutdown&quot;);  </span><br><span class="line">	    &#125;  </span><br><span class="line">	 </span><br><span class="line">	&#125;  </span><br><span class="line">	 </span><br><span class="line">	class PriorityEntity implements Comparable&lt;PriorityEntity&gt; &#123;  </span><br><span class="line">	    private static int count=0;  </span><br><span class="line">	    private int id=count++;  </span><br><span class="line">	    private int priority;  </span><br><span class="line">	    private int index=0;  </span><br><span class="line">	 </span><br><span class="line">	    public PriorityEntity(int _priority,int _index) &#123;  </span><br><span class="line">	        this.priority = _priority;  </span><br><span class="line">	        this.index=_index;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	      </span><br><span class="line">	    public String toString()&#123;  </span><br><span class="line">	        return id+&quot;# [index=&quot;+index+&quot; priority=&quot;+priority+&quot;]&quot;;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	 </span><br><span class="line">	    //数字小，优先级高  </span><br><span class="line">	    public int compareTo(PriorityEntity o) &#123;  </span><br><span class="line">	        return this.priority &gt; o.priority ? 1 </span><br><span class="line">	                : this.priority &lt; o.priority ? -1 : 0;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	 </span><br><span class="line">	    //数字大，优先级高  </span><br><span class="line">	//  public int compareTo(PriorityTask o) &#123;  </span><br><span class="line">	//      return this.priority &lt; o.priority ? 1  </span><br><span class="line">	//              : this.priority &gt; o.priority ? -1 : 0;  </span><br><span class="line">	//  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>实质上就是仅有一个元素的阻塞队列</p>
<h2 id="双端阻塞队列-BlockingDeque"><a href="#双端阻塞队列-BlockingDeque" class="headerlink" title="双端阻塞队列(BlockingDeque)"></a>双端阻塞队列(BlockingDeque)</h2><p>与阻塞队列的区别是它的两端都可以添加或取出元素</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>addFirst(o)</td>
<td>offerFirst(o)</td>
<td>putFirst(o)</td>
<td>offerFirst(o,timeout,timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>removeFirst(o)</td>
<td>pollFirst(o)</td>
<td>takeFirst(o)</td>
<td>pollFirst(o,timeout,timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>getFirst(o)</td>
<td>peekFirst(o)</td>
</tr>
</tbody>
</table>
<p>具体操作与普通阻塞队列一样</p>
<h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><p><strong>ConcurrentHashMap</strong>:常用，介绍略</p>
<p><strong>ConcurrentNavigableMap</strong>：该并发集合能保证它生成的子集合也是并发安全的，常见的生成子map的方法如下:</p>
<h4 id="headMap"><a href="#headMap" class="headerlink" title="headMap()"></a>headMap()</h4><p>headMap(T toKey) 方法返回一个包含了小于给定 toKey 的 key 的子 map。如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素</p>
<h4 id="tailMap"><a href="#tailMap" class="headerlink" title="tailMap()"></a>tailMap()</h4><p>tailMap(T fromKey) 方法返回一个包含了不小于给定 fromKey 的 key 的子 map。<br>如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素</p>
<h4 id="subMap"><a href="#subMap" class="headerlink" title="subMap()"></a>subMap()</h4><p>subMap() 方法返回原始 map 中，键介于 from(包含) 和 to (不包含) 之间的子 map。</p>
<h2 id="常见并发工具"><a href="#常见并发工具" class="headerlink" title="常见并发工具"></a>常见并发工具</h2><h3 id="CountDownLatch（闭锁）"><a href="#CountDownLatch（闭锁）" class="headerlink" title="CountDownLatch（闭锁）"></a>CountDownLatch（闭锁）</h3><p>CountDownLatch 以一个给定的数量初始化。countDown() 每被调用一次，这一数量就减一。通过调用 await() 方法之一，线程可以阻塞等待这一数量到达零。这样可以实现让一个或多个线程等待一系列指定操作的完成后再继续往下执行。以下是一个简单示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch latch = new CountDownLatch(3);  </span><br><span class="line">Waiter      waiter      = new Waiter(latch);  </span><br><span class="line">Decrementer decrementer = new Decrementer(latch);  </span><br><span class="line">new Thread(waiter)     .start();  </span><br><span class="line">new Thread(decrementer).start();  </span><br><span class="line">Thread.sleep(4000);  </span><br><span class="line">public class Waiter implements Runnable&#123;  </span><br><span class="line">    CountDownLatch latch = null;  </span><br><span class="line">    public Waiter(CountDownLatch latch) &#123;  </span><br><span class="line">        this.latch = latch;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            latch.await();   //阻塞等待直到lauch为0</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(&quot;Waiter Released&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">public class Decrementer implements Runnable &#123;  </span><br><span class="line">    CountDownLatch latch = null;  </span><br><span class="line">    public Decrementer(CountDownLatch latch) &#123;  </span><br><span class="line">        this.latch = latch;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            this.latch.countDown();  //执行完特定操作就对latch实行减一操作 </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            this.latch.countDown();  </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            this.latch.countDown();  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier（栅栏）"><a href="#CyclicBarrier（栅栏）" class="headerlink" title="CyclicBarrier（栅栏）"></a>CyclicBarrier（栅栏）</h3><p><img src="http://incdn1.b0.upaiyun.com/2017/09/0c0a50b428245a5dfb6c4250ba010fe0.png" alt=""><br>栅栏能够确保多个线程只有都到达指定状态才能继续往下执行，构造栅栏的方法：CyclicBarrier(int count,Runnable runnable）,count指定等待栅栏的线程数量, runnable指定最后等待栅栏的线程到达后要执行的线程实例。</p>
<p>满足以下任何条件都可以让等待 CyclicBarrier 的线程释放：</p>
<ul>
<li>最后一个线程也到达 CyclicBarrier(调用 await())</li>
<li>当前线程被其他线程打断(其他线程调用了这个线程的 interrupt() 方法)</li>
<li>其他等待栅栏的线程被打断</li>
<li>其他等待栅栏的线程因超时而被释放</li>
<li>外部线程调用了栅栏的 CyclicBarrier.reset() 方法</li>
</ul>
<p>代码示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Runnable barrier1Action = new Runnable() &#123;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        System.out.println(&quot;BarrierAction 1 executed &quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">Runnable barrier2Action = new Runnable() &#123;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        System.out.println(&quot;BarrierAction 2 executed &quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">CyclicBarrier barrier1 = new CyclicBarrier(2, barrier1Action);  </span><br><span class="line">CyclicBarrier barrier2 = new CyclicBarrier(2, barrier2Action);  </span><br><span class="line">CyclicBarrierRunnable barrierRunnable1 =  </span><br><span class="line">        new CyclicBarrierRunnable(barrier1, barrier2);  </span><br><span class="line">CyclicBarrierRunnable barrierRunnable2 =  </span><br><span class="line">        new CyclicBarrierRunnable(barrier1, barrier2);  </span><br><span class="line">new Thread(barrierRunnable1).start();  </span><br><span class="line">new Thread(barrierRunnable2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CyclicBarrierRunnable implements Runnable&#123;  </span><br><span class="line">    CyclicBarrier barrier1 = null;  </span><br><span class="line">    CyclicBarrier barrier2 = null;  </span><br><span class="line">    public CyclicBarrierRunnable(  </span><br><span class="line">            CyclicBarrier barrier1,  </span><br><span class="line">            CyclicBarrier barrier2) &#123;  </span><br><span class="line">        this.barrier1 = barrier1;  </span><br><span class="line">        this.barrier2 = barrier2;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() +  </span><br><span class="line">                                &quot; waiting at barrier 1&quot;);  </span><br><span class="line">            this.barrier1.await();  //线程通过调用栅栏的await方法表示自己已经达到栅栏</span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() +  </span><br><span class="line">                                &quot; waiting at barrier 2&quot;);  </span><br><span class="line">            this.barrier2.await();  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() +  </span><br><span class="line">                                &quot; done!&quot;);  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (BrokenBarrierException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Exchanger-交换机"><a href="#Exchanger-交换机" class="headerlink" title="Exchanger(交换机)"></a>Exchanger(交换机)</h3><p><img src="http://incdn1.b0.upaiyun.com/2017/09/a87d1272cf9d2e199a8c2522747a0651.png" alt=""><br>两个线程通过一个 Exchanger 交换对象。<br>交换对象的动作由 Exchanger 的两个 exchange() 方法的其中一个完成。<br>代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Exchanger exchanger = new Exchanger();  //一个exchanger只能和两个线程关联</span><br><span class="line">ExchangerRunnable exchangerRunnable1 =  </span><br><span class="line">        new ExchangerRunnable(exchanger, &quot;A&quot;);  </span><br><span class="line">ExchangerRunnable exchangerRunnable2 =  </span><br><span class="line">        new ExchangerRunnable(exchanger, &quot;B&quot;);  </span><br><span class="line">new Thread(exchangerRunnable1).start();  </span><br><span class="line">new Thread(exchangerRunnable2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ExchangerRunnable implements Runnable&#123;  </span><br><span class="line">    Exchanger exchanger = null;  </span><br><span class="line">    Object    object    = null;  </span><br><span class="line">    public ExchangerRunnable(Exchanger exchanger, Object object) &#123;  </span><br><span class="line">        this.exchanger = exchanger;  </span><br><span class="line">        this.object = object;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Object previous = this.object;  </span><br><span class="line">            this.object = this.exchanger.exchange(this.object);  </span><br><span class="line">            System.out.println(  </span><br><span class="line">                    Thread.currentThread().getName() +  </span><br><span class="line">                    &quot; exchanged &quot; + previous + &quot; for &quot; + this.object  </span><br><span class="line">            );  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h3><p>java.util.concurrent.Semaphore 类是一个计数信号量。这就意味着它具备两个主要方法：</p>
<ul>
<li>acquire()</li>
<li>release()</li>
</ul>
<p>计数信号量由一个指定数量的 “许可” 初始化。每调用一次 acquire()，一个许可会被调用线程取走。每调用一次 release()，一个许可会被返还给信号量。因此，在没有任何 release() 调用时，最多有 N 个线程能够通过 acquire() 方法，N 是该信号量初始化时的许可的指定数量。这些许可只是一个简单的计数器。这里没啥奇特的地方</p>
<p><strong>Semaphore 用法</strong><br>信号量主要有两种用途：</p>
<ol>
<li>保护一个重要(代码)部分防止一次超过 N 个线程进入。</li>
<li>在两个线程之间发送信号。</li>
</ol>
<p>示例代码如下，该代码具有上述1对应的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreTest &#123;</span><br><span class="line">	 </span><br><span class="line">	    private static int count=0;</span><br><span class="line">	 </span><br><span class="line">	    private static Semaphore semaphore = new Semaphore(4);</span><br><span class="line">	 </span><br><span class="line">	    public static void method() throws InterruptedException &#123;</span><br><span class="line">	 </span><br><span class="line">	        semaphore.acquire();</span><br><span class="line">	        System.out.println(String.format(&quot;当前已经有%d个线程进入该方法&quot;,++count));</span><br><span class="line">	        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">	        semaphore.release();</span><br><span class="line">	        count--;</span><br><span class="line">	 </span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">	 </span><br><span class="line">	        Runnable runnable = new Runnable() &#123;</span><br><span class="line">	            @Override</span><br><span class="line">	            public void run() &#123;</span><br><span class="line">	                try &#123;</span><br><span class="line">	                    method();</span><br><span class="line">	                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">	                    e.printStackTrace();</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;;</span><br><span class="line">	 </span><br><span class="line">	        Thread thread1 = new Thread(runnable,&quot;Thread-1&quot;);</span><br><span class="line">	        Thread thread2 = new Thread(runnable,&quot;Thread-2&quot;);</span><br><span class="line">	        Thread thread3 = new Thread(runnable,&quot;Thread-3&quot;);</span><br><span class="line">	        Thread thread4 = new Thread(runnable,&quot;Thread-4&quot;);</span><br><span class="line">	        Thread thread5 = new Thread(runnable,&quot;Thread-5&quot;);</span><br><span class="line">	        Thread thread6 = new Thread(runnable,&quot;Thread-6&quot;);</span><br><span class="line">	        Thread thread7 = new Thread(runnable,&quot;Thread-7&quot;);</span><br><span class="line">	        Thread thread8 = new Thread(runnable,&quot;Thread-8&quot;);</span><br><span class="line">	 </span><br><span class="line">	        thread1.start();</span><br><span class="line">	        thread2.start();</span><br><span class="line">	        thread3.start();</span><br><span class="line">	        thread4.start();</span><br><span class="line">	        thread5.start();</span><br><span class="line">	        thread6.start();</span><br><span class="line">	        thread7.start();</span><br><span class="line">	        thread8.start();</span><br><span class="line">	 </span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>在线程之间发送信号</strong><br>如果你将一个信号量用于在两个线程之间传送信号，通常你应该用一个线程调用 acquire() 方法，而另一个线程调用 release() 方法。如果没有可用的许可，acquire() 调用将会阻塞，直到一个许可被另一个线程释放出来。同理，如果无法往信号量释放更多许可时，一个 release() 调用也会阻塞。</p>
<p>通过这个可以对多个线程进行协调。比如，如果线程 1 将一个对象插入到了一个共享列表(list)之后之后调用了 acquire()，而线程 2 则在从该列表中获取一个对象之前调用了 release()，这时你其实已经创建了一个阻塞队列。信号量中可用的许可的数量也就等同于该阻塞队列能够持有的元素个数。比较简单，不用演示。。。</p>
<p><strong>公平</strong><br>没有办法保证线程能够公平地可从信号量中获得许可。也就是说，无法担保掉第一个调用 acquire() 的线程会是第一个获得一个许可的线程。如果第一个线程在等待一个许可时发生阻塞，而第二个线程前来索要一个许可的时候刚好有一个许可被释放出来，那么它就可能会在第一个线程之前获得许可。如果你想要强制公平，Semaphore 类有一个具有一个布尔类型的参数的构造子，通过这个参数以告知 Semaphore 是否要强制公平。强制公平会影响到并发性能，所以除非你确实需要它否则不要启用它。<br>以下是如何在公平模式创建一个 Semaphore 的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = new Semaphore(1, true);</span><br></pre></td></tr></table></figure></p>
<h3 id="ExecutorService-执行器服务"><a href="#ExecutorService-执行器服务" class="headerlink" title="ExecutorService(执行器服务)"></a>ExecutorService(执行器服务)</h3><p>java.util.concurrent.ExecutorService 接口表示一个异步执行机制，使我们能够在后台执行任务。因此一个 ExecutorService 很类似于一个线程池。实际上，存在于 java.util.concurrent 包里的 ExecutorService 实现就是一个线程池实现。</p>
<p>创建ExecutorService的两种方式：</p>
<ul>
<li><p>调用Executors类的工厂方法：</p>
<ol>
<li>Executors.newCachedThreadPool();</li>
<li>Executors.newFixedThreadPool();</li>
<li>Executors.newScheduledThreadPool();</li>
<li>Executors.newSingleThreadExecutor();</li>
<li>Executors.newSingleThreadScheduledExecutor()</li>
<li>Executors.newWorkStealingPool();</li>
</ol>
</li>
<li><p>直接利用ExecutorService的实现类ThreadPoolExecutor初始化出一个ExecutorService的实例：<br>ThreadPoolExecutor 包含的线程池能够包含不同数量的线程。池中线程的数量由以下变量决定：</p>
<ul>
<li>corePoolSize</li>
<li>maximumPoolSize</li>
</ul>
<p>当一个任务委托给线程池时，如果池中线程数量低于 corePoolSize，一个新的线程将被创建，即使池中可能尚有空闲线程。如果内部任务队列已满，而且有至少 corePoolSize 正在运行，但是运行线程的数量低于 maximumPoolSize，一个新的线程将被创建去执行该任务。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolServiceImpl implements ThreadPoolService &#123;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(ThreadPoolServiceImpl.class);</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 主线程数</span><br><span class="line">     */</span><br><span class="line">    private int corePoolSize = 20;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 最大线程数</span><br><span class="line">     */</span><br><span class="line">    private int maximumPoolSize = 150;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 线程池维护线程所允许的空闲时间</span><br><span class="line">     */</span><br><span class="line">    private long keepAliveTime = 60;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 单例的线程池类</span><br><span class="line">     */</span><br><span class="line">    private ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line">    </span><br><span class="line">    private ScheduledExecutorService scheduledExecutorService;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 线程池所使用的缓冲队列的大小</span><br><span class="line">     */</span><br><span class="line">    private int queueSize = 100;</span><br><span class="line">    private boolean inited = false;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 当线程池满时，是否阻塞住</span><br><span class="line">     */</span><br><span class="line">    private boolean blockWhenFull = true;</span><br><span class="line"> </span><br><span class="line">    public void init() &#123;</span><br><span class="line">        if(inited) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.threadPoolExecutor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;Runnable&gt;(queueSize), new BlockingQueuePut());</span><br><span class="line">        this.threadPoolExecutor.allowCoreThreadTimeOut(true);</span><br><span class="line">        inited = true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Future&lt;?&gt; addTask(Runnable task) &#123;</span><br><span class="line">        if(!inited) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        return threadPoolExecutor.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setCorePoolSize(int corePoolSize) &#123;</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setMaximumPoolSize(int maximumPoolSize) &#123;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setKeepAliveTime(long keepAliveTime) &#123;</span><br><span class="line">        this.keepAliveTime = keepAliveTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setQueueSize(int queueSize) &#123;</span><br><span class="line">        this.queueSize = queueSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private class BlockingQueuePut implements RejectedExecutionHandler &#123;</span><br><span class="line">        /**</span><br><span class="line">         * define the reject policy when executor queue is full</span><br><span class="line">         * @see java.util.concurrent.RejectedExecutionHandler</span><br><span class="line">         * #rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)</span><br><span class="line">         */</span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">            if(blockWhenFull) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    executor.getQueue().put(r);</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setBlockWhenFull(boolean blockWhenFull) &#123;</span><br><span class="line">        this.blockWhenFull = blockWhenFull;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int getActiveCount() &#123;</span><br><span class="line">        return threadPoolExecutor.getActiveCount();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        threadPoolExecutor.shutdownNow();</span><br><span class="line">        if(scheduledExecutorService != null) &#123;</span><br><span class="line">            scheduledExecutorService.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void loopTask(Runnable task, long interval) &#123;</span><br><span class="line">        loopTask(task, interval, 0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void loopTask(Runnable task, long interval, long delay) &#123;</span><br><span class="line">        if(scheduledExecutorService == null) &#123;</span><br><span class="line">            ThreadFactory threadFactory = new BasicThreadFactory.Builder()</span><br><span class="line">            .namingPattern(&quot;schedule-pool-%d&quot;)</span><br><span class="line">            .daemon(true)</span><br><span class="line">            .build();</span><br><span class="line">            scheduledExecutorService = Executors.newScheduledThreadPool(1, threadFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(interval &lt; 100) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;不允许调度100ms以内的循环任务&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(task, delay, interval, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void runTasksUntilEnd(List&lt;Runnable&gt; tasks) &#123;</span><br><span class="line">        List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;Future&lt;?&gt;&gt;();</span><br><span class="line"> </span><br><span class="line">        for(Runnable task : tasks) &#123;</span><br><span class="line">            futures.add(addTask(task));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(Future&lt;?&gt; f : futures) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                f.get();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.warn(&quot;&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><em>ScheduledExecutorService（定时执行者服务)</em></strong><br>java.util.concurrent.ScheduledExecutorService 是一个 ExecutorService， 它能够将任务延后执行，或者间隔固定时间多次执行。 任务由一个工作者线程异步执行，而不是由提交任务给 ScheduledExecutorService 的那个线程执行。示例程序见上面的程序示例。。。</p>
<p><strong><em>ExecutouService的常见方法</em></strong></p>
<ul>
<li>execute(Runnable)：执行一个Runnable示例，用于执行不需要返回信息的任务</li>
<li>submit(Runnable)：执行一个Runnable示例，与execute的区别是它可以回查Runnable示例的执行状态</li>
<li>submit(Callable)：执行一个Callable示例，用于执行需要返回信息的任务</li>
<li>invokeAny(…)：执行一系列Callable示例，如果有一个Callable示例执行完成则其它Callable任务将被取消</li>
<li>invokeAll(…)：执行一系列Callable示例，返回所有Callable示例的执行结果</li>
</ul>
<h3 id="ForkJoinPool（分叉合并池执行池）"><a href="#ForkJoinPool（分叉合并池执行池）" class="headerlink" title="ForkJoinPool（分叉合并池执行池）"></a>ForkJoinPool（分叉合并池执行池）</h3><p>ForkJoinPool 在 Java 7 中被引入。它和 ExecutorService 很相似，除了一点不同。ForkJoinPool 让我们可以很方便地把任务分裂成几个更小的任务，这些分裂出来的任务也将会提交给 ForkJoinPool。任务可以继续分割成更小的子任务，只要它还能分割。可能听起来有些抽象，因此本节中我们将会解释 ForkJoinPool 是如何工作的，还有任务分割是如何进行的。</p>
<p><strong><em>分叉和合并解释</em></strong></p>
<p>在我们开始看 ForkJoinPool 之前我们先来简要解释一下分叉和合并的原理。<br>分叉和合并原理包含两个递归进行的步骤。两个步骤分别是分叉步骤和合并步骤</p>
<p><strong><em>分叉</em></strong><br><img src="http://incdn1.b0.upaiyun.com/2017/09/411d4e8c8ae237bdd6fc22469d1c1880.png" alt=""><br>通过把自己分割成多个子任务，每个子任务可以由不同的 CPU 并行执行，或者被同一个 CPU 上的不同线程执行。只有当给的任务过大，把它分割成几个子任务才有意义。把任务分割成子任务有一定开销，因此对于小型任务，这个分割的消耗可能比每个子任务并发执行的消耗还要大。<br>什么时候把一个任务分割成子任务是有意义的，这个界限也称作一个阀值。这要看每个任务对有意义阀值的决定。很大程度上取决于它要做的工作的种类</p>
<p><strong><em>合并</em></strong></p>
<p>当一个任务将自己分割成若干子任务之后，该任务将进入等待所有子任务的结束之中。一旦子任务执行结束，该任务可以把所有结果合并到同一个结果。图示如下：<br><img src="http://incdn1.b0.upaiyun.com/2017/09/6f5e15d2343bffb3f75201a5ad812208.png" alt=""><br>当然，并非所有类型的任务都会返回一个结果。如果这个任务并不返回一个结果，它只需等待所有子任务执行完毕。也就不需要结果的合并啦。</p>
<p><strong><em>创建一个 ForkJoinPool</em></strong></p>
<p>你可以通过其构造子创建一个 ForkJoinPool。作为传递给 ForkJoinPool 构造子的一个参数，你可以定义你期望的并行级别。并行级别表示你想要传递给 ForkJoinPool 的任务所需的线程或 CPU 数量。以下是一个 ForkJoinPool 示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool forkJoinPool = new ForkJoinPool(4);</span><br></pre></td></tr></table></figure></p>
<p><strong><em>提交任务到 ForkJoinPool</em></strong><br>就像提交任务到 ExecutorService 那样，把任务提交到 ForkJoinPool。你可以提交两种类型的任务。一种是没有任何返回值的(一个 “行动”)，另一种是有返回值的(一个”任务”)。这两种类型分别由 RecursiveAction 和 RecursiveTask 表示。接下来介绍如何使用这两种类型的任务，以及如何对它们进行提交。</p>
<p><strong><em>RecursiveAction</em></strong></p>
<p>RecursiveAction 是一种没有任何返回值的任务。它只是做一些工作，比如写数据到磁盘，然后就退出了。一个 RecursiveAction 可以把自己的工作分割成更小的几块，这样它们可以由独立的线程或者 CPU 执行。你可以通过继承来实现一个 RecursiveAction。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecursiveAction extends RecursiveAction &#123;  </span><br><span class="line">    private long workLoad = 0;  </span><br><span class="line">    public MyRecursiveAction(long workLoad) &#123;  </span><br><span class="line">        this.workLoad = workLoad;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override </span><br><span class="line">    protected void compute() &#123;  </span><br><span class="line">        </span><br><span class="line">        if(this.workLoad &gt; 16) &#123;  </span><br><span class="line">            System.out.println(&quot;Splitting workLoad : &quot; + this.workLoad);  </span><br><span class="line">            List&lt;MyRecursiveAction&gt; subtasks =  </span><br><span class="line">                new ArrayList&lt;MyRecursiveAction&gt;();  </span><br><span class="line">            subtasks.addAll(createSubtasks());  </span><br><span class="line">            for(RecursiveAction subtask : subtasks)&#123;  </span><br><span class="line">                subtask.fork();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            System.out.println(&quot;Doing workLoad myself: &quot; + this.workLoad);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    private List&lt;MyRecursiveAction&gt; createSubtasks() &#123;  </span><br><span class="line">        List&lt;MyRecursiveAction&gt; subtasks =  </span><br><span class="line">            new ArrayList&lt;MyRecursiveAction&gt;();  </span><br><span class="line">        MyRecursiveAction subtask1 = new MyRecursiveAction(this.workLoad / 2);  </span><br><span class="line">        MyRecursiveAction subtask2 = new MyRecursiveAction(this.workLoad / 2);  </span><br><span class="line">        subtasks.add(subtask1);  </span><br><span class="line">        subtasks.add(subtask2);  </span><br><span class="line">        return subtasks;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子很简单。MyRecursiveAction 将一个虚构的 workLoad 作为参数传给自己的构造子。如果 workLoad 高于一个特定阀值，该工作将被分割为几个子工作，子工作继续分割。如果 workLoad 低于特定阀值，该工作将由 MyRecursiveAction 自己执行。你可以这样规划一个 MyRecursiveAction 的执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyRecursiveAction myRecursiveAction = new MyRecursiveAction(24);  </span><br><span class="line">forkJoinPool.invoke(myRecursiveAction);</span><br></pre></td></tr></table></figure></p>
<p><strong><em>RecursiveTask</em></strong><br>RecursiveTask 是一种会返回结果的任务。它可以将自己的工作分割为若干更小任务，并将这些子任务的执行结果合并到一个集体结果。可以有几个水平的分割和合并。以下是一个 RecursiveTask 示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecursiveTask extends RecursiveTask&lt;Long&gt;</span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line">        private long workLoad = 0;  </span><br><span class="line">	    public MyRecursiveTask(long workLoad)&#123;  </span><br><span class="line">	        this.workLoad = workLoad;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    protected Long compute () &#123;  </span><br><span class="line">	        </span><br><span class="line">	        if (this.workLoad &gt; 16)&#123;  </span><br><span class="line">	            System.out.println(&quot;Splitting workLoad : &quot;  + this.workLoad);  </span><br><span class="line">	            List&lt;MyRecursiveTask&gt; subtasks =  </span><br><span class="line">	                new ArrayList&lt;MyRecursiveTask&gt; ();  </span><br><span class="line">	            subtasks.addAll(createSubtasks());  </span><br><span class="line">	            for (MyRecursiveTask subtask : subtasks) &#123;  </span><br><span class="line">	                subtask.fork();  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            long result = 0;  </span><br><span class="line">	            for (MyRecursiveTask subtask : subtasks) &#123;  </span><br><span class="line">	                result += subtask.join();  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            return result;  </span><br><span class="line">	        &#125; else &#123;  </span><br><span class="line">	            System.out.println(&quot;Doing workLoad myself: &quot;  + this.workLoad);  </span><br><span class="line">	            return workLoad * 3;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    private List&lt;MyRecursiveTask&gt; createSubtasks () &#123;  </span><br><span class="line">	        List&lt;MyRecursiveTask&gt; subtasks =  </span><br><span class="line">	        new ArrayList&lt;MyRecursiveTask&gt; ();  </span><br><span class="line">	        MyRecursiveTask subtask1 = new MyRecursiveTask(this.workLoad / 2);  </span><br><span class="line">	        MyRecursiveTask subtask2 = new MyRecursiveTask(this.workLoad / 2);  </span><br><span class="line">	        subtasks.add(subtask1);  </span><br><span class="line">	        subtasks.add(subtask2);  </span><br><span class="line">	        return subtasks;  </span><br><span class="line">	    &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>除了有一个结果返回之外，这个示例和 RecursiveAction 的例子很像。MyRecursiveTask 类继承自 RecursiveTask<long>，这也就意味着它将返回一个 Long 类型的结果。MyRecursiveTask 示例也会将工作分割为子任务，并通过 fork() 方法对这些子任务计划执行。此外，本示例还通过调用每个子任务的 join() 方法收集它们返回的结果。子任务的结果随后被合并到一个更大的结果，并最终将其返回。对于不同级别的递归，这种子任务的结果合并可能会发生递归。</long></p>
<p>你可以这样规划一个 RecursiveTask：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyRecursiveTask myRecursiveTask = new MyRecursiveTask(128);  </span><br><span class="line">long mergedResult = forkJoinPool.invoke(myRecursiveTask);  </span><br><span class="line">System.out.println(&quot;mergedResult = &quot; + mergedResult);</span><br></pre></td></tr></table></figure></p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>java.util.concurrent.locks.Lock 是一个类似于 synchronized 块的线程同步机制。但是 Lock 比 synchronized 块更加灵活、精细。java.util.concurrent.locks中提供了lock的实现ReentrantLock。</p>
<p><strong><em>Lock 和 synchronized 代码块的主要不同点</em></strong><br>一个 Lock 对象和一个 synchronized 代码块之间的主要不同点是：</p>
<ul>
<li>synchronized 代码块不能够保证进入访问等待的线程的先后顺序</li>
<li>你不能够传递任何参数给一个 synchronized 代码块的入口。因此，对于 synchronized 代码块的访问等待设置超时时间是不可能的事情。</li>
<li>synchronized 块必须被完整地包含在单个方法里。而一个 Lock 对象可以把它的 lock() 和 unlock() 方法的调用放在不同的方法里。</li>
</ul>
<p>Lock 接口具有以下主要方法：</p>
<ul>
<li>lock()：将lock实例锁定，如果lock实例已被其他线程锁定则该方法阻塞，直到lock实例被解锁</li>
<li>lockInterruptibly()：锁定lock实例，除非该线程被打断。如果一旦因Lock实例已被锁定而进入阻塞，则如果它被外部打断则退出该方法的调用。</li>
<li>tryLock()：以永不阻塞的方式尝试锁定lock实例，若锁定成功立即返回true,否则若lock实例已被锁定立即返回false</li>
<li>tryLock(long timeout, TimeUnit timeUnit)：与tryLock()类似，只是它能指定在放弃锁定之前的最长等待时间。</li>
<li>unlock()：解锁lock实例，只允许锁定相应lock实例的线程调用该方法，否则抛出一个未检查异常。</li>
</ul>
<p><strong><em>ReentrantLock</em></strong></p>
<p>lock的基本实现，使用简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();  </span><br><span class="line">…….</span><br><span class="line">lock.lock();  </span><br><span class="line">…….</span><br><span class="line">…….</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure></p>
<p><strong><em>ReadWriteLock</em></strong></p>
<p>java.util.concurrent.locks.ReadWriteLock 读写锁是一种先进的线程锁机制。它能够允许多个线程在同一时间对某特定资源进行读取，但同一时间内只能有一个线程对其进行写入。</p>
<p>读写锁的理念在于多个线程能够对一个共享资源进行读取，而不会导致并发问题。并发问题的发生场景在于对一个共享资源的读和写操作的同时进行，或者多个写操作并发进行。</p>
<p>ReadWriteLock 锁规则</p>
<p>一个线程在对受保护资源在读或者写之前对 ReadWriteLock 锁定的规则如下：</p>
<ul>
<li><strong><em>读锁</em></strong>：如果没有任何写操作线程锁定 ReadWriteLock，并且没有任何写操作线程要求一个写锁(但还没有获得该锁)。因此，可以有多个读操作线程对该锁进行锁定。</li>
<li><strong><em>写锁</em></strong>：如果没有任何读操作或者写操作。因此，在写操作的时候，只能有一个线程对该锁进行锁定。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();</span><br><span class="line">reentrantReadWriteLock.readLock().lock();</span><br><span class="line"> …..</span><br><span class="line"> </span><br><span class="line">reentrantReadWriteLock.readLock().unlock();</span><br><span class="line"> </span><br><span class="line">reentrantReadWriteLock.writeLock().lock();</span><br><span class="line"> …….</span><br><span class="line"> </span><br><span class="line">reentrantReadWriteLock.writeLock().unlock();</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析zookeeper的典型应用场景]]></title>
      <url>/2017/12/20/%E6%B5%85%E6%9E%90zookeeper%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<blockquote>
<p>平时写业务不免要用到一些分布式的中间件，例如dubbo、Kafka等，它们都有一个共同点，那就是都以zookeeper作为注册中心。由此可见在zookeeper在处理分布式应用中的地位。既然如此，有必要对zookeeper进行一番学习。本人初学zookeeper，刚好看了zookeeper的一些典型应用场景，所以就在此利用zookeeper的java api简单地实现一番。当然要声明的是在zk的正式应用中远比这些demo要做的复杂、考虑的全面的多。但是就像标题所写，这里是“浅析”，这些demo至少能够在凸显原理的基础上具有“浅析”之用。</p>
</blockquote>
<h3 id="基于java的zookeeper相关的api"><a href="#基于java的zookeeper相关的api" class="headerlink" title="基于java的zookeeper相关的api"></a>基于java的zookeeper相关的api</h3><p>  由于本文中所有场景的实现都要借助于Java语言，所以这里利用apache提供的官方包加以实现。首先需要作简要介绍:</p>
<ol>
<li><p>ZooKeeper(String connectString, int sessionTimeout, Watcher watcher) throws IOException ：创建zookeeper实例，对zookeeper的所有操作都将依赖于该实例。<br>• connectString— zookeeper server列表, 以逗号隔开. ZooKeeper对象初始化后, 将从server列表中选择一个server, 并尝试与其建立连接. 如果连接建立失败, 则会从列表的剩余项中选择一个server, 并再次尝试建立连接. • sessionTimeout— 指定连接的超时时间. • watcher— 事件回调接口.</p>
</li>
<li><p>String create(String path, byte[] data, List acl, CreateMode createMode) : 创建节点<br>• path— znode的路径. • data— 与znode关联的数据. • acl— 指定权限信息, 如果不想指定权限, 可以传入Ids.OPENACLUNSAFE. • createMode— 指定znode类型. CreateMode是一个枚举类, 从中选择一个成员传入即可. 常见有以下几种模式 : PERSISTENT(创建持久化节点) PERSISTENTSEQUENTIAL(创建有序的持久化节点) EPHEMERAL(创建临时节点) EPHEMERALSEQUENTIAL(创建有序的临时节点)。所谓临时节点是指创建该节点的客户端一旦失去连接，则节点自动删除</p>
</li>
<li><p>List getChildren(String path, boolean watch)：获取指定节点的所有子节点<br>• watch— 参数用于指定是否监听path node的子node的增加和删除事件, 以及path node本身的删除事件.</p>
</li>
<li><p>Stat exists(String path, boolean watch)：检测指定节点的状态，可以绑定监控事件<br>• watch参数用于指定是否监听path node的创建, 删除事件, 以及数据更新事件. 如果该node存在, 则返回该node的状态信息, 否则返回null.</p>
</li>
<li><p>byte[] getData(String path, boolean watch, Stat stat)：获取指定节点上的数据<br>• watch— 参数用于指定是否监听path node的删除事件, 以及数据更新事件, 注意, 不监听path node的创建事件, 因为如果path node不存在, 该方法将抛出KeeperException.NoNodeException异常. • stat— 参数是个传出参数, getData方法会将path node的状态信息设置到该参数中.</p>
</li>
<li><p>Stat setData(final String path, byte data[], int version)：更新指定节点上存储的数据<br>• data— 为待更新的数据. • version— 参数指定要更新的数据的版本, 如果version和真实的版本不同, 更新操作将失败. 指定version为-1则忽略版本检查.</p>
</li>
<li><p>void delete(final String path, int version)：删除指定节点，可以指定删除指定版本</p>
</li>
</ol>
<h3 id="典型应用场景的浅析"><a href="#典型应用场景的浅析" class="headerlink" title="典型应用场景的浅析"></a>典型应用场景的浅析</h3><h4 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a><em>动态配置</em></h4><p>  由于zookeeper的节点上能够存储数据，如果客户端持续在节点上监听，也能实时地监测节点上数据的变化。借助这些特性可以利用zookeeper实现简单的远程动态配置管理。实现思路如下:</p>
<ul>
<li>指定zk服务端一个特定znode作为特定配置文件的存放点</li>
<li>配置文件可以以json序列化的形式存储，也就是每个配置文件对应一个json字符串存于相应znode上</li>
<li>客户端应用需要设置相应的监控回调watcher，一旦znode上存储的配置信息发生变更则将触发watcher,watcher中可以处理同步的逻辑。<br>代码大致如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">//获取应用内配置文件的路径</span><br><span class="line">public static String getFilePath() &#123;</span><br><span class="line">    return System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/resources/&quot; + FILENAME;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化zonode</span><br><span class="line">public static void initPath(String path) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zooKeeper = getZookeeperClient();</span><br><span class="line">        Stat stat = zooKeeper.exists(path, false);</span><br><span class="line">        if (stat == null) &#123;</span><br><span class="line">            zooKeeper.create(path, path.substring(1).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同步zknode上的配置信息到应用中</span><br><span class="line">public void handleUpdate() &#123;</span><br><span class="line">    FileWriter fileWriter = null;</span><br><span class="line">    ZooKeeper zk = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        zk = getZookeeperClient();</span><br><span class="line">        byte[] data = zk.getData(PROPERTIES_PATH, false, null);</span><br><span class="line">        String jsonStr = new String(data);</span><br><span class="line">        Map&lt;String, String&gt; map = JSON.parseObject(jsonStr, Map.class);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            sb.append(entry.getKey() + &quot;=&quot; + entry.getValue()).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        fileWriter = new FileWriter(getFilePath());</span><br><span class="line">        fileWriter.write(sb.toString());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (fileWriter != null) &#123;</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//借助zookeeper实现简单的动态配置</span><br><span class="line">public void testAutoSetPropertiesFile() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(PROPERTIES_PATH);</span><br><span class="line">    ZooKeeper zooKeeper = null;</span><br><span class="line">    final SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line">    try &#123;</span><br><span class="line">        //注册客户端时设置对配置节点的监听器</span><br><span class="line">        zooKeeper = getZookeeperClient(new Watcher() &#123;</span><br><span class="line">            public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">                if (watchedEvent.getType() != Event.EventType.None) &#123;</span><br><span class="line">                    LOGGER.info(&quot;配置文件发生了改变,开始同步到本地...&quot;);</span><br><span class="line">                    handleUpdate();  //监测到远程配置发生改变时进行本地同步</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.put(1);  //同步完成后注意解锁，以重新激活监听</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        LOGGER.error(e.getMessage());</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        File file = new File(getFilePath());</span><br><span class="line">        if (!file.exists()) &#123;  //本地应用第一次同步</span><br><span class="line">            handleUpdate();</span><br><span class="line">        &#125;</span><br><span class="line">        while (zooKeeper.exists(PROPERTIES_PATH, true) != null) &#123;   //通过exists方法持续激活监听器</span><br><span class="line">            queue.take();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，最重要的是在初始化zk时绑定了用于同步配置的Watcher()，然后调用exists(path,isWatch)时设isWatch为true即可使Watcher生效。需要注意的是Watcher一旦被调用一次后即失效，所以在这里循环调用exists(path,isWatch)使Watcher重新生效以达到持续监听的效果。使用了SynchronousQueue用于在远程配置无变化时就阻塞住线程，避免无限循环。</p>
<h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a><em>集群管理</em></h4><p>由于zk除了能够监听znode本身的状态外也能监控其子节点的状态，所以利用这一点可以很方便地构建出一个集群模型。利用一台主机持续对集群服务的公用注册节点下的子节点进行监控，这样在公用节点下注册的服务的变动都将被主机检测到。这里为了方便地检测到服务的上下线所以服务都已临时节点的方式注册，这样只要服务一断开则相应节点被删除就可被监控到，新服务的上线同理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">    //用于集群管理的watcher</span><br><span class="line">    public class ClusterWatcher implements Watcher &#123;</span><br><span class="line"></span><br><span class="line">        ZooKeeper zooKeeper;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; lock = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        public ClusterWatcher() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                zooKeeper = getZookeeperClient();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //用于在监听器触发时进行相关处理</span><br><span class="line">        public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">            if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.put(1);</span><br><span class="line">                    synchronized (zooKeeper) &#123;</span><br><span class="line">                        int chidren_actual = zooKeeper.getChildren(CLUSTER_PATH, false).size();</span><br><span class="line">                        //服务中心节点上储存有触发器触发前集群中子节点的数量</span><br><span class="line">                        int children_before = Integer.valueOf(new String(zooKeeper.getData(</span><br><span class="line">                                CLUSTER_PATH, false, null)));</span><br><span class="line">                        zooKeeper.setData(CLUSTER_PATH, String.valueOf(chidren_actual).getBytes(), -1);</span><br><span class="line">                        //通过对比触发器触发后服务中心下的实际子节点数量和触发前的子节点数量分辨是上线还是下线行为</span><br><span class="line">                        if (chidren_actual &gt; children_before) &#123;</span><br><span class="line">                            LOGGER.info(&quot;集群中有新服务上线...&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            LOGGER.info(&quot;集群中有服务下线...&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (KeeperException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void await() throws InterruptedException &#123;</span><br><span class="line">            lock.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//zookeeper模拟集群管理</span><br><span class="line">    public void simulateCluster() &#123;</span><br><span class="line"></span><br><span class="line">        initPath(CLUSTER_PATH);</span><br><span class="line">        LOGGER.info(&quot;模拟集群已初始化完毕，持续监听注册的客户端状态...&quot;);</span><br><span class="line">        final SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            ClusterWatcher clusterWatcher = new ClusterWatcher();</span><br><span class="line">            //初始化客户端连接时设置对中心服务节点的监听器</span><br><span class="line">            ZooKeeper zk = getZookeeperClient(clusterWatcher);</span><br><span class="line">            int serverCounts = zk.getChildren(CLUSTER_PATH, false).size();</span><br><span class="line">            //子服务每次上线时先在中心节点上存储一下当前的总的子服务的数量</span><br><span class="line">            zk.setData(CLUSTER_PATH, String.valueOf(serverCounts).getBytes(), -1);</span><br><span class="line">            //通过循环调用getChildren持续激活监听器</span><br><span class="line">            while (zk.getChildren(CLUSTER_PATH, true) != null) &#123; </span><br><span class="line">                clusterWatcher.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>关键点还是持续监控上，由于每次父节点下的子节点变动触发watcher后就会导致watcher失效。所以还是要在watcher每次被调用后立即重新让它生效，所以上面循环调用zk.getChildren(CLUSTER_PATH,true)。而且上面对服务的上下线的判断依赖于父节点始终存储着子节点变动前的子节点总数，子节点一旦变化则在watcher中将其与实时的子节点总数作对比。其实这里只是浅层次地实现了对集群中服务的在线状态实行监控，对集群的管理远不止这些，包括集群中leader的动态选择，这些大家可以自己去尝试，也比较简单。测试代码就不贴了，就是异步添加和删除多个临时节点的过程。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><em>分布式锁</em></h4><p>利用zk实现分布式锁也是依赖于znode，加锁解锁往往依赖于节点的创建删除。具体思路如下：</p>
<ul>
<li>建立一个父节点base_node</li>
<li>每当有应用要获取一个锁时则先到base_node下创建一个有序的临时节点</li>
<li>获取base_node 所有子节点集合并排序选出其中最小的节点，将其与2中创建的节点进行对比，判断最小的节点是不是2创建的节点</li>
<li>如果3判断最小的节点即是2创建的节点则获取锁成功，可以继续去处理加锁的业务；否则获取锁失败，可以阻塞住等待最小的节点离线，即其它应用解锁。</li>
<li>处理完业务后通过删除节点达到解锁的效果。 分析上面的思路可以发现，一旦一个刚创建的节点是最小的节点则加锁成功，这时如果外部有新的节点建立，由于是有序节点则新建立的节点肯定比当前存在的锁节点大，只能等待锁节点的删除才能成为最小的节点。<br>关键代码如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//zookeeper实现分布式锁</span><br><span class="line">public void simulateLock() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(LOCK_PATH);</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zk = getZookeeperClient();</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        String newNode = zk.create(LOCK_PATH + &quot;/&quot; + currentTime, String.valueOf(currentTime).getBytes(),</span><br><span class="line">                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);  //创建锁节点</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = zk.getChildren(LOCK_PATH, false);</span><br><span class="line">        String[] nodes = list.toArray(new String[list.size()]);</span><br><span class="line">        Arrays.sort(nodes);</span><br><span class="line">        if (newNode.equals(LOCK_PATH + &quot;/&quot; + nodes[0])) &#123;  //与zk中最小的锁节点比较，相同则获取锁成功</span><br><span class="line">            LOGGER.info(&quot;获取锁成功&quot;);</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            zk.close();    //由于创建的锁节点是临时节点，所以客户端退出即删除相应节点</span><br><span class="line">            lock_wait.put(1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LOGGER.info(&quot;获取锁失败，持续等待&quot;);</span><br><span class="line">            lock_wait.take();</span><br><span class="line">            zk.close();   //退出客户端以删除获取锁失败时创建的节点</span><br><span class="line">            simulateLock();  //尝试重新获取锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是lockwait是已经声明的一个静态的SynchronousQueue，一旦线程获取锁失败则通过lockwait.take()阻塞住，一旦线程释放锁完成则通过lock.wait.put()唤醒其它获取锁陷入阻塞的线程，之后这些线程可以重试锁。</p>
<h4 id="分布式阻塞队列"><a href="#分布式阻塞队列" class="headerlink" title="分布式阻塞队列"></a><em>分布式阻塞队列</em></h4><p>这里实现一个分布式的生产者-消费者模型的阻塞队列。原理比较简单，如下简述:</p>
<ul>
<li>建立一个队列的父节点，队列中的元素都将存储于其子节点中，入队则是新建子节点，出队则是删除子节点。</li>
<li>创建的子节点都是有序节点，这样保证队列中元素的有序性。</li>
<li>当入队时先检测当前父节点下的子节点数是否已经超出队列的最大容量，如果是则阻塞住等待元素的出队。出队时先检测父节点的子节点集是否为空，如果是则阻塞住等待元素的入队。<br>关键代码如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//用于分布式队列的监听器</span><br><span class="line">public class QueueWatcher implements Watcher &#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    public QueueWatcher() &#123;</span><br><span class="line">        latch = new CountDownLatch(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">        if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">            LOGGER.info(&quot;队列成员发生变更...&quot;);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void await() throws InterruptedException &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//zookeeper实现阻塞队列的生产者</span><br><span class="line">public void simulateProducer() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(QUEUE_PATH);</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zk = getZookeeperClient();</span><br><span class="line">        while (zk.exists(QUEUE_PATH, false) != null) &#123;</span><br><span class="line">            QueueWatcher watcher = new QueueWatcher();</span><br><span class="line">            //队列中元素超过上限时通过监听器中的锁阻塞</span><br><span class="line">            if (zk.getChildren(QUEUE_PATH, watcher).size() &gt;= queueSize) &#123;</span><br><span class="line">                LOGGER.info(&quot;由于队列已满，进入阻塞状态...&quot;);</span><br><span class="line">                watcher.await();</span><br><span class="line">            &#125;</span><br><span class="line">            //新元素入队</span><br><span class="line">            zk.create(QUEUE_PATH + &quot;/elem-&quot;, String.valueOf(System.currentTimeMillis()).getBytes(),</span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//zookeeper实现阻塞队列的消费者</span><br><span class="line">public void simulateCustomer() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(QUEUE_PATH);</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zk = getZookeeperClient();</span><br><span class="line">        while (zk.exists(QUEUE_PATH, false) != null) &#123;</span><br><span class="line">            QueueWatcher watcher = new QueueWatcher();</span><br><span class="line">            List&lt;String&gt; nodes = zk.getChildren(QUEUE_PATH, watcher);</span><br><span class="line">            //队列为空时阻塞</span><br><span class="line">            if (nodes.isEmpty()) &#123;</span><br><span class="line">                LOGGER.info(&quot;由于队列已空，消费者线程进入阻塞状态...&quot;);</span><br><span class="line">                watcher.await();</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //每次从队列中出队最小的元素</span><br><span class="line">                String[] products = nodes.toArray(new String[nodes.size()]);</span><br><span class="line">                Arrays.sort(products);</span><br><span class="line">                String path = QUEUE_PATH + &quot;/&quot; + products[0];</span><br><span class="line">                LOGGER.info(&quot;模拟处理队列&#123;&#125;中的&#123;&#125;元素对应的数据&quot;, QUEUE_PATH, path);</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">                zk.delete(path, -1);</span><br><span class="line">                LOGGER.info(&quot;处理完后从队列&#123;&#125;移除元素&#123;&#125;&quot;, QUEUE_PATH, path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<div class="github-widget" data-repo="smartcong007/ZookeeperUtils"></div>]]></content>
      
        
    </entry>
    
  
  
</search>
