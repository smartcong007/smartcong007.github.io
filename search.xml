<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[JAVA oncurrent包学习总结]]></title>
      <url>/2017/12/24/JAVA-oncurrent%E5%8C%85%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>concurrent包是java中专门用来处理并发的包，并发编程的基础便是对这个包下的常用api的熟练使用。由于并发场景的复杂和多样性，常常会有<br>  很多不同的并发手段。此文对常见的并发api进行梳理。</p>
</blockquote>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>java中有阻塞队列的各种不同实现，都是实现自BlockingQueue接口，包含：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<p>BlockingQueue接口中有一组通用的方法对比如下，一般使用频率最高的是阻塞方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(o)</td>
<td>offer(o)</td>
<td>put(o)</td>
<td>offer(o,timeout,timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove(o)</td>
<td>poll(o)</td>
<td>take(o)</td>
<td>poll(timeout,timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>element(o)</td>
<td>peek(o) </td>
</tr>
</tbody>
</table>
<p>四组不同的行为方式解释：</p>
<p><strong>抛异常</strong>：如果试图的操作无法立即执行，抛一个异常。</p>
<p><strong>特定值</strong>：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</p>
<p><strong>阻塞</strong>：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</p>
<p><strong>超时</strong>：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>数组阻塞队列是一个有界的阻塞队列，内部实现是将对象放到一个数组中。它有一个同一时间能存储元素数量的上限。其内部对元素采用FIFO的顺序存储元素，即队列头部放置的是放入时间最久的元素，底部放置最新放入的元素。<br>简单实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue queue = new ArrayBlockingQueue(1024);  </span><br><span class="line">queue.put(&quot;1&quot;);  </span><br><span class="line">Object object = queue.take();</span><br></pre></td></tr></table></figure>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>延迟队列中的元素都有一个特定的延迟时间来确定其过期时间，如果未到达其过期时间对该元素调用take()将阻塞，到达过期时间后调用take()才能移除元素。阻塞队列中的元素都要实现Delayed接口。具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class Item&lt;T&gt; implements Delayed &#123;</span><br><span class="line">	</span><br><span class="line">	    private static final long NANO_ORIGIN = System.nanoTime();</span><br><span class="line">	</span><br><span class="line">	    private static final AtomicLong sequencer = new AtomicLong(0);</span><br><span class="line">	</span><br><span class="line">	    private final long sequenceNumber;</span><br><span class="line">	</span><br><span class="line">	    private final long time;</span><br><span class="line">	</span><br><span class="line">	    private final T content;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	    public Item(T content,long timeout)&#123;</span><br><span class="line">	</span><br><span class="line">	        this.content = content;</span><br><span class="line">	        this.time = now()+timeout;</span><br><span class="line">	        this.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">	</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    final static long now()&#123;</span><br><span class="line">	        return System.nanoTime() - NANO_ORIGIN;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	    @Override</span><br><span class="line">	    public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">	</span><br><span class="line">	        long d = unit.convert(time-now(),TimeUnit.NANOSECONDS);</span><br><span class="line">	        return d;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    @Override</span><br><span class="line">	    public int compareTo(Delayed o) &#123;</span><br><span class="line">	</span><br><span class="line">	        if (o == this)&#123;</span><br><span class="line">	            return 0;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        if(o instanceof Item)&#123;</span><br><span class="line">	            Item i = (Item) o;</span><br><span class="line">	            long con = time-i.time;</span><br><span class="line">	            if (con&lt;0) return -1;</span><br><span class="line">	            else if(con&gt;0) return 1;</span><br><span class="line">	            else if(sequenceNumber&lt;i.sequenceNumber) return -1;</span><br><span class="line">	            else return 1;</span><br><span class="line">	</span><br><span class="line">	        &#125;</span><br><span class="line">	        long d = (getDelay(TimeUnit.NANOSECONDS)-o.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">	        return d==0?0:((d &lt; 0) ? -1 : 1);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    public T getContent() &#123;</span><br><span class="line">	        return content;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">		 </span><br><span class="line">	ConcurrentTest.class:</span><br><span class="line">	</span><br><span class="line">	package com.cong.test;</span><br><span class="line">	</span><br><span class="line">	import java.util.concurrent.DelayQueue;</span><br><span class="line">	import java.util.concurrent.TimeUnit;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * Created by zhengcong on 2017/9/13.</span><br><span class="line">	 */</span><br><span class="line">	public class ConcurrentTest &#123;</span><br><span class="line">	</span><br><span class="line">	    private static DelayQueue&lt;Item&lt;String&gt;&gt; delayQueue = new DelayQueue&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	</span><br><span class="line">	        delayQueue.add(new Item(&quot;zheng&quot;, TimeUnit.NANOSECONDS.convert(6, TimeUnit.SECONDS)));</span><br><span class="line">	        Item&lt;String&gt; item;</span><br><span class="line">	        item = delayQueue.take();</span><br><span class="line">	        if (item != null) &#123;</span><br><span class="line">	            System.out.println(item.getContent());</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>内部以链式结构存储元素，如不指定上限，将以Integer.MAX_VALUE作为上限，采用FIFO的方式存储元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; unbounded = new LinkedBlockingQueue&lt;String&gt;();  </span><br><span class="line">BlockingQueue&lt;String&gt; bounded   = new LinkedBlockingQueue&lt;String&gt;(1024);  </span><br><span class="line">bounded.put(&quot;Value&quot;);  </span><br><span class="line">String value = bounded.take();</span><br></pre></td></tr></table></figure></p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>优先阻塞队列，队列中的元素必须实现java.lang.Comparable接口，由元素具体的compare()的具体实现决定了元素在队列中的存储顺序。注意：如果用Iterator对其进行枚举并不能保证它对元素的遍历是以优先级为序的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class TestPriorityQueue &#123;  </span><br><span class="line">	   </span><br><span class="line">	    static Random r=new Random(47);  </span><br><span class="line">	      </span><br><span class="line">	    public static void main(String args[]) throws InterruptedException&#123;  </span><br><span class="line">	        final PriorityBlockingQueue q=new PriorityBlockingQueue();  </span><br><span class="line">	        ExecutorService se=Executors.newCachedThreadPool();  </span><br><span class="line">	        //execute producer  </span><br><span class="line">	        se.execute(new Runnable()&#123;  </span><br><span class="line">	            public void run() &#123;  </span><br><span class="line">	                int i=0;  </span><br><span class="line">	                while(true)&#123;  </span><br><span class="line">	                    q.put(new PriorityEntity(r.nextInt(10),i++));  </span><br><span class="line">	                    try &#123;  </span><br><span class="line">	                        TimeUnit.MILLISECONDS.sleep(r.nextInt(1000));  </span><br><span class="line">	                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	                        // TODO Auto-generated catch block  </span><br><span class="line">	                        e.printStackTrace();  </span><br><span class="line">	                    &#125;  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;); </span><br><span class="line">	          </span><br><span class="line">	        //execute consumer  </span><br><span class="line">	        se.execute(new Runnable()&#123;  </span><br><span class="line">	            public void run() &#123;  </span><br><span class="line">	                while(true)&#123;  </span><br><span class="line">	                    try &#123;  </span><br><span class="line">	                        System.out.println(&quot;take-- &quot;+q.take()+&quot; left:-- [&quot;+q.toString()+&quot;]&quot;);  </span><br><span class="line">	                        try &#123;  </span><br><span class="line">	                            TimeUnit.MILLISECONDS.sleep(r.nextInt(1000));  </span><br><span class="line">	                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	                            // TODO Auto-generated catch block  </span><br><span class="line">	                            e.printStackTrace();  </span><br><span class="line">	                        &#125;  </span><br><span class="line">	                    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	                        e.printStackTrace();  </span><br><span class="line">	                    &#125;  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;);  </span><br><span class="line">	        try &#123;  </span><br><span class="line">	            TimeUnit.SECONDS.sleep(5);  </span><br><span class="line">	        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">	            // TODO Auto-generated catch block  </span><br><span class="line">	            e.printStackTrace();  </span><br><span class="line">	        &#125;  </span><br><span class="line">	        System.out.println(&quot;shutdown&quot;);  </span><br><span class="line">	    &#125;  </span><br><span class="line">	 </span><br><span class="line">	&#125;  </span><br><span class="line">	 </span><br><span class="line">	class PriorityEntity implements Comparable&lt;PriorityEntity&gt; &#123;  </span><br><span class="line">	    private static int count=0;  </span><br><span class="line">	    private int id=count++;  </span><br><span class="line">	    private int priority;  </span><br><span class="line">	    private int index=0;  </span><br><span class="line">	 </span><br><span class="line">	    public PriorityEntity(int _priority,int _index) &#123;  </span><br><span class="line">	        this.priority = _priority;  </span><br><span class="line">	        this.index=_index;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	      </span><br><span class="line">	    public String toString()&#123;  </span><br><span class="line">	        return id+&quot;# [index=&quot;+index+&quot; priority=&quot;+priority+&quot;]&quot;;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	 </span><br><span class="line">	    //数字小，优先级高  </span><br><span class="line">	    public int compareTo(PriorityEntity o) &#123;  </span><br><span class="line">	        return this.priority &gt; o.priority ? 1 </span><br><span class="line">	                : this.priority &lt; o.priority ? -1 : 0;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	 </span><br><span class="line">	    //数字大，优先级高  </span><br><span class="line">	//  public int compareTo(PriorityTask o) &#123;  </span><br><span class="line">	//      return this.priority &lt; o.priority ? 1  </span><br><span class="line">	//              : this.priority &gt; o.priority ? -1 : 0;  </span><br><span class="line">	//  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>实质上就是仅有一个元素的阻塞队列</p>
<h2 id="双端阻塞队列-BlockingDeque"><a href="#双端阻塞队列-BlockingDeque" class="headerlink" title="双端阻塞队列(BlockingDeque)"></a>双端阻塞队列(BlockingDeque)</h2><p>与阻塞队列的区别是它的两端都可以添加或取出元素</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>addFirst(o)</td>
<td>offerFirst(o)</td>
<td>putFirst(o)</td>
<td>offerFirst(o,timeout,timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>removeFirst(o)</td>
<td>pollFirst(o)</td>
<td>takeFirst(o)</td>
<td>pollFirst(o,timeout,timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>getFirst(o)</td>
<td>peekFirst(o)</td>
</tr>
</tbody>
</table>
<p>具体操作与普通阻塞队列一样</p>
<h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><p><strong>ConcurrentHashMap</strong>:常用，介绍略</p>
<p><strong>ConcurrentNavigableMap</strong>：该并发集合能保证它生成的子集合也是并发安全的，常见的生成子map的方法如下:</p>
<h4 id="headMap"><a href="#headMap" class="headerlink" title="headMap()"></a>headMap()</h4><p>headMap(T toKey) 方法返回一个包含了小于给定 toKey 的 key 的子 map。如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素</p>
<h4 id="tailMap"><a href="#tailMap" class="headerlink" title="tailMap()"></a>tailMap()</h4><p>tailMap(T fromKey) 方法返回一个包含了不小于给定 fromKey 的 key 的子 map。<br>如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素</p>
<h4 id="subMap"><a href="#subMap" class="headerlink" title="subMap()"></a>subMap()</h4><p>subMap() 方法返回原始 map 中，键介于 from(包含) 和 to (不包含) 之间的子 map。</p>
<h2 id="常见并发工具"><a href="#常见并发工具" class="headerlink" title="常见并发工具"></a>常见并发工具</h2><h3 id="CountDownLatch（闭锁）"><a href="#CountDownLatch（闭锁）" class="headerlink" title="CountDownLatch（闭锁）"></a>CountDownLatch（闭锁）</h3><p>CountDownLatch 以一个给定的数量初始化。countDown() 每被调用一次，这一数量就减一。通过调用 await() 方法之一，线程可以阻塞等待这一数量到达零。这样可以实现让一个或多个线程等待一系列指定操作的完成后再继续往下执行。以下是一个简单示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch latch = new CountDownLatch(3);  </span><br><span class="line">Waiter      waiter      = new Waiter(latch);  </span><br><span class="line">Decrementer decrementer = new Decrementer(latch);  </span><br><span class="line">new Thread(waiter)     .start();  </span><br><span class="line">new Thread(decrementer).start();  </span><br><span class="line">Thread.sleep(4000);  </span><br><span class="line">public class Waiter implements Runnable&#123;  </span><br><span class="line">    CountDownLatch latch = null;  </span><br><span class="line">    public Waiter(CountDownLatch latch) &#123;  </span><br><span class="line">        this.latch = latch;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            latch.await();   //阻塞等待直到lauch为0</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(&quot;Waiter Released&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">public class Decrementer implements Runnable &#123;  </span><br><span class="line">    CountDownLatch latch = null;  </span><br><span class="line">    public Decrementer(CountDownLatch latch) &#123;  </span><br><span class="line">        this.latch = latch;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            this.latch.countDown();  //执行完特定操作就对latch实行减一操作 </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            this.latch.countDown();  </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            this.latch.countDown();  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier（栅栏）"><a href="#CyclicBarrier（栅栏）" class="headerlink" title="CyclicBarrier（栅栏）"></a>CyclicBarrier（栅栏）</h3><p><img src="http://incdn1.b0.upaiyun.com/2017/09/0c0a50b428245a5dfb6c4250ba010fe0.png" alt=""><br>栅栏能够确保多个线程只有都到达指定状态才能继续往下执行，构造栅栏的方法：CyclicBarrier(int count,Runnable runnable）,count指定等待栅栏的线程数量, runnable指定最后等待栅栏的线程到达后要执行的线程实例。</p>
<p>满足以下任何条件都可以让等待 CyclicBarrier 的线程释放：</p>
<ul>
<li>最后一个线程也到达 CyclicBarrier(调用 await())</li>
<li>当前线程被其他线程打断(其他线程调用了这个线程的 interrupt() 方法)</li>
<li>其他等待栅栏的线程被打断</li>
<li>其他等待栅栏的线程因超时而被释放</li>
<li>外部线程调用了栅栏的 CyclicBarrier.reset() 方法</li>
</ul>
<p>代码示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Runnable barrier1Action = new Runnable() &#123;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        System.out.println(&quot;BarrierAction 1 executed &quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">Runnable barrier2Action = new Runnable() &#123;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        System.out.println(&quot;BarrierAction 2 executed &quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">CyclicBarrier barrier1 = new CyclicBarrier(2, barrier1Action);  </span><br><span class="line">CyclicBarrier barrier2 = new CyclicBarrier(2, barrier2Action);  </span><br><span class="line">CyclicBarrierRunnable barrierRunnable1 =  </span><br><span class="line">        new CyclicBarrierRunnable(barrier1, barrier2);  </span><br><span class="line">CyclicBarrierRunnable barrierRunnable2 =  </span><br><span class="line">        new CyclicBarrierRunnable(barrier1, barrier2);  </span><br><span class="line">new Thread(barrierRunnable1).start();  </span><br><span class="line">new Thread(barrierRunnable2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CyclicBarrierRunnable implements Runnable&#123;  </span><br><span class="line">    CyclicBarrier barrier1 = null;  </span><br><span class="line">    CyclicBarrier barrier2 = null;  </span><br><span class="line">    public CyclicBarrierRunnable(  </span><br><span class="line">            CyclicBarrier barrier1,  </span><br><span class="line">            CyclicBarrier barrier2) &#123;  </span><br><span class="line">        this.barrier1 = barrier1;  </span><br><span class="line">        this.barrier2 = barrier2;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() +  </span><br><span class="line">                                &quot; waiting at barrier 1&quot;);  </span><br><span class="line">            this.barrier1.await();  //线程通过调用栅栏的await方法表示自己已经达到栅栏</span><br><span class="line">            Thread.sleep(1000);  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() +  </span><br><span class="line">                                &quot; waiting at barrier 2&quot;);  </span><br><span class="line">            this.barrier2.await();  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() +  </span><br><span class="line">                                &quot; done!&quot;);  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (BrokenBarrierException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Exchanger-交换机"><a href="#Exchanger-交换机" class="headerlink" title="Exchanger(交换机)"></a>Exchanger(交换机)</h3><p><img src="http://incdn1.b0.upaiyun.com/2017/09/a87d1272cf9d2e199a8c2522747a0651.png" alt=""><br>两个线程通过一个 Exchanger 交换对象。<br>交换对象的动作由 Exchanger 的两个 exchange() 方法的其中一个完成。<br>代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Exchanger exchanger = new Exchanger();  //一个exchanger只能和两个线程关联</span><br><span class="line">ExchangerRunnable exchangerRunnable1 =  </span><br><span class="line">        new ExchangerRunnable(exchanger, &quot;A&quot;);  </span><br><span class="line">ExchangerRunnable exchangerRunnable2 =  </span><br><span class="line">        new ExchangerRunnable(exchanger, &quot;B&quot;);  </span><br><span class="line">new Thread(exchangerRunnable1).start();  </span><br><span class="line">new Thread(exchangerRunnable2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ExchangerRunnable implements Runnable&#123;  </span><br><span class="line">    Exchanger exchanger = null;  </span><br><span class="line">    Object    object    = null;  </span><br><span class="line">    public ExchangerRunnable(Exchanger exchanger, Object object) &#123;  </span><br><span class="line">        this.exchanger = exchanger;  </span><br><span class="line">        this.object = object;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Object previous = this.object;  </span><br><span class="line">            this.object = this.exchanger.exchange(this.object);  </span><br><span class="line">            System.out.println(  </span><br><span class="line">                    Thread.currentThread().getName() +  </span><br><span class="line">                    &quot; exchanged &quot; + previous + &quot; for &quot; + this.object  </span><br><span class="line">            );  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h3><p>java.util.concurrent.Semaphore 类是一个计数信号量。这就意味着它具备两个主要方法：</p>
<ul>
<li>acquire()</li>
<li>release()</li>
</ul>
<p>计数信号量由一个指定数量的 “许可” 初始化。每调用一次 acquire()，一个许可会被调用线程取走。每调用一次 release()，一个许可会被返还给信号量。因此，在没有任何 release() 调用时，最多有 N 个线程能够通过 acquire() 方法，N 是该信号量初始化时的许可的指定数量。这些许可只是一个简单的计数器。这里没啥奇特的地方</p>
<p><strong>Semaphore 用法</strong><br>信号量主要有两种用途：</p>
<ol>
<li>保护一个重要(代码)部分防止一次超过 N 个线程进入。</li>
<li>在两个线程之间发送信号。</li>
</ol>
<p>示例代码如下，该代码具有上述1对应的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreTest &#123;</span><br><span class="line">	 </span><br><span class="line">	    private static int count=0;</span><br><span class="line">	 </span><br><span class="line">	    private static Semaphore semaphore = new Semaphore(4);</span><br><span class="line">	 </span><br><span class="line">	    public static void method() throws InterruptedException &#123;</span><br><span class="line">	 </span><br><span class="line">	        semaphore.acquire();</span><br><span class="line">	        System.out.println(String.format(&quot;当前已经有%d个线程进入该方法&quot;,++count));</span><br><span class="line">	        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">	        semaphore.release();</span><br><span class="line">	        count--;</span><br><span class="line">	 </span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">	    public static void main(String[] args) &#123;</span><br><span class="line">	 </span><br><span class="line">	        Runnable runnable = new Runnable() &#123;</span><br><span class="line">	            @Override</span><br><span class="line">	            public void run() &#123;</span><br><span class="line">	                try &#123;</span><br><span class="line">	                    method();</span><br><span class="line">	                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">	                    e.printStackTrace();</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;;</span><br><span class="line">	 </span><br><span class="line">	        Thread thread1 = new Thread(runnable,&quot;Thread-1&quot;);</span><br><span class="line">	        Thread thread2 = new Thread(runnable,&quot;Thread-2&quot;);</span><br><span class="line">	        Thread thread3 = new Thread(runnable,&quot;Thread-3&quot;);</span><br><span class="line">	        Thread thread4 = new Thread(runnable,&quot;Thread-4&quot;);</span><br><span class="line">	        Thread thread5 = new Thread(runnable,&quot;Thread-5&quot;);</span><br><span class="line">	        Thread thread6 = new Thread(runnable,&quot;Thread-6&quot;);</span><br><span class="line">	        Thread thread7 = new Thread(runnable,&quot;Thread-7&quot;);</span><br><span class="line">	        Thread thread8 = new Thread(runnable,&quot;Thread-8&quot;);</span><br><span class="line">	 </span><br><span class="line">	        thread1.start();</span><br><span class="line">	        thread2.start();</span><br><span class="line">	        thread3.start();</span><br><span class="line">	        thread4.start();</span><br><span class="line">	        thread5.start();</span><br><span class="line">	        thread6.start();</span><br><span class="line">	        thread7.start();</span><br><span class="line">	        thread8.start();</span><br><span class="line">	 </span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>在线程之间发送信号</strong><br>如果你将一个信号量用于在两个线程之间传送信号，通常你应该用一个线程调用 acquire() 方法，而另一个线程调用 release() 方法。如果没有可用的许可，acquire() 调用将会阻塞，直到一个许可被另一个线程释放出来。同理，如果无法往信号量释放更多许可时，一个 release() 调用也会阻塞。</p>
<p>通过这个可以对多个线程进行协调。比如，如果线程 1 将一个对象插入到了一个共享列表(list)之后之后调用了 acquire()，而线程 2 则在从该列表中获取一个对象之前调用了 release()，这时你其实已经创建了一个阻塞队列。信号量中可用的许可的数量也就等同于该阻塞队列能够持有的元素个数。比较简单，不用演示。。。</p>
<p><strong>公平</strong><br>没有办法保证线程能够公平地可从信号量中获得许可。也就是说，无法担保掉第一个调用 acquire() 的线程会是第一个获得一个许可的线程。如果第一个线程在等待一个许可时发生阻塞，而第二个线程前来索要一个许可的时候刚好有一个许可被释放出来，那么它就可能会在第一个线程之前获得许可。如果你想要强制公平，Semaphore 类有一个具有一个布尔类型的参数的构造子，通过这个参数以告知 Semaphore 是否要强制公平。强制公平会影响到并发性能，所以除非你确实需要它否则不要启用它。<br>以下是如何在公平模式创建一个 Semaphore 的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = new Semaphore(1, true);</span><br></pre></td></tr></table></figure></p>
<h3 id="ExecutorService-执行器服务"><a href="#ExecutorService-执行器服务" class="headerlink" title="ExecutorService(执行器服务)"></a>ExecutorService(执行器服务)</h3><p>java.util.concurrent.ExecutorService 接口表示一个异步执行机制，使我们能够在后台执行任务。因此一个 ExecutorService 很类似于一个线程池。实际上，存在于 java.util.concurrent 包里的 ExecutorService 实现就是一个线程池实现。</p>
<p>创建ExecutorService的两种方式：</p>
<ul>
<li><p>调用Executors类的工厂方法：</p>
<ol>
<li>Executors.newCachedThreadPool();</li>
<li>Executors.newFixedThreadPool();</li>
<li>Executors.newScheduledThreadPool();</li>
<li>Executors.newSingleThreadExecutor();</li>
<li>Executors.newSingleThreadScheduledExecutor()</li>
<li>Executors.newWorkStealingPool();</li>
</ol>
</li>
<li><p>直接利用ExecutorService的实现类ThreadPoolExecutor初始化出一个ExecutorService的实例：<br>ThreadPoolExecutor 包含的线程池能够包含不同数量的线程。池中线程的数量由以下变量决定：</p>
<ul>
<li>corePoolSize</li>
<li>maximumPoolSize</li>
</ul>
<p>当一个任务委托给线程池时，如果池中线程数量低于 corePoolSize，一个新的线程将被创建，即使池中可能尚有空闲线程。如果内部任务队列已满，而且有至少 corePoolSize 正在运行，但是运行线程的数量低于 maximumPoolSize，一个新的线程将被创建去执行该任务。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolServiceImpl implements ThreadPoolService &#123;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(ThreadPoolServiceImpl.class);</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 主线程数</span><br><span class="line">     */</span><br><span class="line">    private int corePoolSize = 20;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 最大线程数</span><br><span class="line">     */</span><br><span class="line">    private int maximumPoolSize = 150;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 线程池维护线程所允许的空闲时间</span><br><span class="line">     */</span><br><span class="line">    private long keepAliveTime = 60;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 单例的线程池类</span><br><span class="line">     */</span><br><span class="line">    private ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line">    </span><br><span class="line">    private ScheduledExecutorService scheduledExecutorService;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 线程池所使用的缓冲队列的大小</span><br><span class="line">     */</span><br><span class="line">    private int queueSize = 100;</span><br><span class="line">    private boolean inited = false;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 当线程池满时，是否阻塞住</span><br><span class="line">     */</span><br><span class="line">    private boolean blockWhenFull = true;</span><br><span class="line"> </span><br><span class="line">    public void init() &#123;</span><br><span class="line">        if(inited) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.threadPoolExecutor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;Runnable&gt;(queueSize), new BlockingQueuePut());</span><br><span class="line">        this.threadPoolExecutor.allowCoreThreadTimeOut(true);</span><br><span class="line">        inited = true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Future&lt;?&gt; addTask(Runnable task) &#123;</span><br><span class="line">        if(!inited) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        return threadPoolExecutor.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setCorePoolSize(int corePoolSize) &#123;</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setMaximumPoolSize(int maximumPoolSize) &#123;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setKeepAliveTime(long keepAliveTime) &#123;</span><br><span class="line">        this.keepAliveTime = keepAliveTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setQueueSize(int queueSize) &#123;</span><br><span class="line">        this.queueSize = queueSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private class BlockingQueuePut implements RejectedExecutionHandler &#123;</span><br><span class="line">        /**</span><br><span class="line">         * define the reject policy when executor queue is full</span><br><span class="line">         * @see java.util.concurrent.RejectedExecutionHandler</span><br><span class="line">         * #rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)</span><br><span class="line">         */</span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">            if(blockWhenFull) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    executor.getQueue().put(r);</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setBlockWhenFull(boolean blockWhenFull) &#123;</span><br><span class="line">        this.blockWhenFull = blockWhenFull;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int getActiveCount() &#123;</span><br><span class="line">        return threadPoolExecutor.getActiveCount();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        threadPoolExecutor.shutdownNow();</span><br><span class="line">        if(scheduledExecutorService != null) &#123;</span><br><span class="line">            scheduledExecutorService.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void loopTask(Runnable task, long interval) &#123;</span><br><span class="line">        loopTask(task, interval, 0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void loopTask(Runnable task, long interval, long delay) &#123;</span><br><span class="line">        if(scheduledExecutorService == null) &#123;</span><br><span class="line">            ThreadFactory threadFactory = new BasicThreadFactory.Builder()</span><br><span class="line">            .namingPattern(&quot;schedule-pool-%d&quot;)</span><br><span class="line">            .daemon(true)</span><br><span class="line">            .build();</span><br><span class="line">            scheduledExecutorService = Executors.newScheduledThreadPool(1, threadFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(interval &lt; 100) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;不允许调度100ms以内的循环任务&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(task, delay, interval, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void runTasksUntilEnd(List&lt;Runnable&gt; tasks) &#123;</span><br><span class="line">        List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;Future&lt;?&gt;&gt;();</span><br><span class="line"> </span><br><span class="line">        for(Runnable task : tasks) &#123;</span><br><span class="line">            futures.add(addTask(task));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(Future&lt;?&gt; f : futures) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                f.get();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.warn(&quot;&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><em>ScheduledExecutorService（定时执行者服务)</em></strong><br>java.util.concurrent.ScheduledExecutorService 是一个 ExecutorService， 它能够将任务延后执行，或者间隔固定时间多次执行。 任务由一个工作者线程异步执行，而不是由提交任务给 ScheduledExecutorService 的那个线程执行。示例程序见上面的程序示例。。。</p>
<p><strong><em>ExecutouService的常见方法</em></strong></p>
<ul>
<li>execute(Runnable)：执行一个Runnable示例，用于执行不需要返回信息的任务</li>
<li>submit(Runnable)：执行一个Runnable示例，与execute的区别是它可以回查Runnable示例的执行状态</li>
<li>submit(Callable)：执行一个Callable示例，用于执行需要返回信息的任务</li>
<li>invokeAny(…)：执行一系列Callable示例，如果有一个Callable示例执行完成则其它Callable任务将被取消</li>
<li>invokeAll(…)：执行一系列Callable示例，返回所有Callable示例的执行结果</li>
</ul>
<h3 id="ForkJoinPool（分叉合并池执行池）"><a href="#ForkJoinPool（分叉合并池执行池）" class="headerlink" title="ForkJoinPool（分叉合并池执行池）"></a>ForkJoinPool（分叉合并池执行池）</h3><p>ForkJoinPool 在 Java 7 中被引入。它和 ExecutorService 很相似，除了一点不同。ForkJoinPool 让我们可以很方便地把任务分裂成几个更小的任务，这些分裂出来的任务也将会提交给 ForkJoinPool。任务可以继续分割成更小的子任务，只要它还能分割。可能听起来有些抽象，因此本节中我们将会解释 ForkJoinPool 是如何工作的，还有任务分割是如何进行的。</p>
<p><strong><em>分叉和合并解释</em></strong></p>
<p>在我们开始看 ForkJoinPool 之前我们先来简要解释一下分叉和合并的原理。<br>分叉和合并原理包含两个递归进行的步骤。两个步骤分别是分叉步骤和合并步骤</p>
<p><strong><em>分叉</em></strong><br><img src="http://incdn1.b0.upaiyun.com/2017/09/411d4e8c8ae237bdd6fc22469d1c1880.png" alt=""><br>通过把自己分割成多个子任务，每个子任务可以由不同的 CPU 并行执行，或者被同一个 CPU 上的不同线程执行。只有当给的任务过大，把它分割成几个子任务才有意义。把任务分割成子任务有一定开销，因此对于小型任务，这个分割的消耗可能比每个子任务并发执行的消耗还要大。<br>什么时候把一个任务分割成子任务是有意义的，这个界限也称作一个阀值。这要看每个任务对有意义阀值的决定。很大程度上取决于它要做的工作的种类</p>
<p><strong><em>合并</em></strong></p>
<p>当一个任务将自己分割成若干子任务之后，该任务将进入等待所有子任务的结束之中。一旦子任务执行结束，该任务可以把所有结果合并到同一个结果。图示如下：<br><img src="http://www.importnew.com/26461.html/5401760-d3f822dbc4045bb9" alt=""><br>当然，并非所有类型的任务都会返回一个结果。如果这个任务并不返回一个结果，它只需等待所有子任务执行完毕。也就不需要结果的合并啦。</p>
<p><strong><em>创建一个 ForkJoinPool</em></strong></p>
<p>你可以通过其构造子创建一个 ForkJoinPool。作为传递给 ForkJoinPool 构造子的一个参数，你可以定义你期望的并行级别。并行级别表示你想要传递给 ForkJoinPool 的任务所需的线程或 CPU 数量。以下是一个 ForkJoinPool 示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool forkJoinPool = new ForkJoinPool(4);</span><br></pre></td></tr></table></figure></p>
<p><strong><em>提交任务到 ForkJoinPool</em></strong><br>就像提交任务到 ExecutorService 那样，把任务提交到 ForkJoinPool。你可以提交两种类型的任务。一种是没有任何返回值的(一个 “行动”)，另一种是有返回值的(一个”任务”)。这两种类型分别由 RecursiveAction 和 RecursiveTask 表示。接下来介绍如何使用这两种类型的任务，以及如何对它们进行提交。</p>
<p><strong><em>RecursiveAction</em></strong></p>
<p>RecursiveAction 是一种没有任何返回值的任务。它只是做一些工作，比如写数据到磁盘，然后就退出了。一个 RecursiveAction 可以把自己的工作分割成更小的几块，这样它们可以由独立的线程或者 CPU 执行。你可以通过继承来实现一个 RecursiveAction。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecursiveAction extends RecursiveAction &#123;  </span><br><span class="line">    private long workLoad = 0;  </span><br><span class="line">    public MyRecursiveAction(long workLoad) &#123;  </span><br><span class="line">        this.workLoad = workLoad;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override </span><br><span class="line">    protected void compute() &#123;  </span><br><span class="line">        </span><br><span class="line">        if(this.workLoad &gt; 16) &#123;  </span><br><span class="line">            System.out.println(&quot;Splitting workLoad : &quot; + this.workLoad);  </span><br><span class="line">            List&lt;MyRecursiveAction&gt; subtasks =  </span><br><span class="line">                new ArrayList&lt;MyRecursiveAction&gt;();  </span><br><span class="line">            subtasks.addAll(createSubtasks());  </span><br><span class="line">            for(RecursiveAction subtask : subtasks)&#123;  </span><br><span class="line">                subtask.fork();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            System.out.println(&quot;Doing workLoad myself: &quot; + this.workLoad);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    private List&lt;MyRecursiveAction&gt; createSubtasks() &#123;  </span><br><span class="line">        List&lt;MyRecursiveAction&gt; subtasks =  </span><br><span class="line">            new ArrayList&lt;MyRecursiveAction&gt;();  </span><br><span class="line">        MyRecursiveAction subtask1 = new MyRecursiveAction(this.workLoad / 2);  </span><br><span class="line">        MyRecursiveAction subtask2 = new MyRecursiveAction(this.workLoad / 2);  </span><br><span class="line">        subtasks.add(subtask1);  </span><br><span class="line">        subtasks.add(subtask2);  </span><br><span class="line">        return subtasks;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子很简单。MyRecursiveAction 将一个虚构的 workLoad 作为参数传给自己的构造子。如果 workLoad 高于一个特定阀值，该工作将被分割为几个子工作，子工作继续分割。如果 workLoad 低于特定阀值，该工作将由 MyRecursiveAction 自己执行。你可以这样规划一个 MyRecursiveAction 的执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyRecursiveAction myRecursiveAction = new MyRecursiveAction(24);  </span><br><span class="line">forkJoinPool.invoke(myRecursiveAction);</span><br></pre></td></tr></table></figure></p>
<p><strong><em>RecursiveTask</em></strong><br>RecursiveTask 是一种会返回结果的任务。它可以将自己的工作分割为若干更小任务，并将这些子任务的执行结果合并到一个集体结果。可以有几个水平的分割和合并。以下是一个 RecursiveTask 示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecursiveTask extends RecursiveTask&lt;Long&gt;</span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line">        private long workLoad = 0;  </span><br><span class="line">	    public MyRecursiveTask(long workLoad)&#123;  </span><br><span class="line">	        this.workLoad = workLoad;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    protected Long compute () &#123;  </span><br><span class="line">	        </span><br><span class="line">	        if (this.workLoad &gt; 16)&#123;  </span><br><span class="line">	            System.out.println(&quot;Splitting workLoad : &quot;  + this.workLoad);  </span><br><span class="line">	            List&lt;MyRecursiveTask&gt; subtasks =  </span><br><span class="line">	                new ArrayList&lt;MyRecursiveTask&gt; ();  </span><br><span class="line">	            subtasks.addAll(createSubtasks());  </span><br><span class="line">	            for (MyRecursiveTask subtask : subtasks) &#123;  </span><br><span class="line">	                subtask.fork();  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            long result = 0;  </span><br><span class="line">	            for (MyRecursiveTask subtask : subtasks) &#123;  </span><br><span class="line">	                result += subtask.join();  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            return result;  </span><br><span class="line">	        &#125; else &#123;  </span><br><span class="line">	            System.out.println(&quot;Doing workLoad myself: &quot;  + this.workLoad);  </span><br><span class="line">	            return workLoad * 3;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    private List&lt;MyRecursiveTask&gt; createSubtasks () &#123;  </span><br><span class="line">	        List&lt;MyRecursiveTask&gt; subtasks =  </span><br><span class="line">	        new ArrayList&lt;MyRecursiveTask&gt; ();  </span><br><span class="line">	        MyRecursiveTask subtask1 = new MyRecursiveTask(this.workLoad / 2);  </span><br><span class="line">	        MyRecursiveTask subtask2 = new MyRecursiveTask(this.workLoad / 2);  </span><br><span class="line">	        subtasks.add(subtask1);  </span><br><span class="line">	        subtasks.add(subtask2);  </span><br><span class="line">	        return subtasks;  </span><br><span class="line">	    &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>除了有一个结果返回之外，这个示例和 RecursiveAction 的例子很像。MyRecursiveTask 类继承自 RecursiveTask<long>，这也就意味着它将返回一个 Long 类型的结果。MyRecursiveTask 示例也会将工作分割为子任务，并通过 fork() 方法对这些子任务计划执行。此外，本示例还通过调用每个子任务的 join() 方法收集它们返回的结果。子任务的结果随后被合并到一个更大的结果，并最终将其返回。对于不同级别的递归，这种子任务的结果合并可能会发生递归。</long></p>
<p>你可以这样规划一个 RecursiveTask：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyRecursiveTask myRecursiveTask = new MyRecursiveTask(128);  </span><br><span class="line">long mergedResult = forkJoinPool.invoke(myRecursiveTask);  </span><br><span class="line">System.out.println(&quot;mergedResult = &quot; + mergedResult);</span><br></pre></td></tr></table></figure></p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>java.util.concurrent.locks.Lock 是一个类似于 synchronized 块的线程同步机制。但是 Lock 比 synchronized 块更加灵活、精细。java.util.concurrent.locks中提供了lock的实现ReentrantLock。</p>
<p><strong><em>Lock 和 synchronized 代码块的主要不同点</em></strong><br>一个 Lock 对象和一个 synchronized 代码块之间的主要不同点是：</p>
<ul>
<li>synchronized 代码块不能够保证进入访问等待的线程的先后顺序</li>
<li>你不能够传递任何参数给一个 synchronized 代码块的入口。因此，对于 synchronized 代码块的访问等待设置超时时间是不可能的事情。</li>
<li>synchronized 块必须被完整地包含在单个方法里。而一个 Lock 对象可以把它的 lock() 和 unlock() 方法的调用放在不同的方法里。</li>
</ul>
<p>Lock 接口具有以下主要方法：</p>
<ul>
<li>lock()：将lock实例锁定，如果lock实例已被其他线程锁定则该方法阻塞，直到lock实例被解锁</li>
<li>lockInterruptibly()：锁定lock实例，除非该线程被打断。如果一旦因Lock实例已被锁定而进入阻塞，则如果它被外部打断则退出该方法的调用。</li>
<li>tryLock()：以永不阻塞的方式尝试锁定lock实例，若锁定成功立即返回true,否则若lock实例已被锁定立即返回false</li>
<li>tryLock(long timeout, TimeUnit timeUnit)：与tryLock()类似，只是它能指定在放弃锁定之前的最长等待时间。</li>
<li>unlock()：解锁lock实例，只允许锁定相应lock实例的线程调用该方法，否则抛出一个未检查异常。</li>
</ul>
<p><strong><em>ReentrantLock</em></strong></p>
<p>lock的基本实现，使用简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();  </span><br><span class="line">…….</span><br><span class="line">lock.lock();  </span><br><span class="line">…….</span><br><span class="line">…….</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure></p>
<p><strong><em>ReadWriteLock</em></strong></p>
<p>java.util.concurrent.locks.ReadWriteLock 读写锁是一种先进的线程锁机制。它能够允许多个线程在同一时间对某特定资源进行读取，但同一时间内只能有一个线程对其进行写入。</p>
<p>读写锁的理念在于多个线程能够对一个共享资源进行读取，而不会导致并发问题。并发问题的发生场景在于对一个共享资源的读和写操作的同时进行，或者多个写操作并发进行。</p>
<p>ReadWriteLock 锁规则</p>
<p>一个线程在对受保护资源在读或者写之前对 ReadWriteLock 锁定的规则如下：</p>
<ul>
<li><strong><em>读锁</em></strong>：如果没有任何写操作线程锁定 ReadWriteLock，并且没有任何写操作线程要求一个写锁(但还没有获得该锁)。因此，可以有多个读操作线程对该锁进行锁定。</li>
<li><strong><em>写锁</em></strong>：如果没有任何读操作或者写操作。因此，在写操作的时候，只能有一个线程对该锁进行锁定。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();</span><br><span class="line">reentrantReadWriteLock.readLock().lock();</span><br><span class="line"> …..</span><br><span class="line"> </span><br><span class="line">reentrantReadWriteLock.readLock().unlock();</span><br><span class="line"> </span><br><span class="line">reentrantReadWriteLock.writeLock().lock();</span><br><span class="line"> …….</span><br><span class="line"> </span><br><span class="line">reentrantReadWriteLock.writeLock().unlock();</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析zookeeper的典型应用场景]]></title>
      <url>/2017/12/20/%E6%B5%85%E6%9E%90zookeeper%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<blockquote>
<p>平时写业务不免要用到一些分布式的中间件，例如dubbo、Kafka等，它们都有一个共同点，那就是都以zookeeper作为注册中心。由此可见在zookeeper在处理分布式应用中的地位。既然如此，有必要对zookeeper进行一番学习。本人初学zookeeper，刚好看了zookeeper的一些典型应用场景，所以就在此利用zookeeper的java api简单地实现一番。当然要声明的是在zk的正式应用中远比这些demo要做的复杂、考虑的全面的多。但是就像标题所写，这里是“浅析”，这些demo至少能够在凸显原理的基础上具有“浅析”之用。</p>
</blockquote>
<h3 id="基于java的zookeeper相关的api"><a href="#基于java的zookeeper相关的api" class="headerlink" title="基于java的zookeeper相关的api"></a>基于java的zookeeper相关的api</h3><p>  由于本文中所有场景的实现都要借助于Java语言，所以这里利用apache提供的官方包加以实现。首先需要作简要介绍:</p>
<ol>
<li><p>ZooKeeper(String connectString, int sessionTimeout, Watcher watcher) throws IOException ：创建zookeeper实例，对zookeeper的所有操作都将依赖于该实例。<br>• connectString— zookeeper server列表, 以逗号隔开. ZooKeeper对象初始化后, 将从server列表中选择一个server, 并尝试与其建立连接. 如果连接建立失败, 则会从列表的剩余项中选择一个server, 并再次尝试建立连接. • sessionTimeout— 指定连接的超时时间. • watcher— 事件回调接口.</p>
</li>
<li><p>String create(String path, byte[] data, List acl, CreateMode createMode) : 创建节点<br>• path— znode的路径. • data— 与znode关联的数据. • acl— 指定权限信息, 如果不想指定权限, 可以传入Ids.OPENACLUNSAFE. • createMode— 指定znode类型. CreateMode是一个枚举类, 从中选择一个成员传入即可. 常见有以下几种模式 : PERSISTENT(创建持久化节点) PERSISTENTSEQUENTIAL(创建有序的持久化节点) EPHEMERAL(创建临时节点) EPHEMERALSEQUENTIAL(创建有序的临时节点)。所谓临时节点是指创建该节点的客户端一旦失去连接，则节点自动删除</p>
</li>
<li><p>List getChildren(String path, boolean watch)：获取指定节点的所有子节点<br>• watch— 参数用于指定是否监听path node的子node的增加和删除事件, 以及path node本身的删除事件.</p>
</li>
<li><p>Stat exists(String path, boolean watch)：检测指定节点的状态，可以绑定监控事件<br>• watch参数用于指定是否监听path node的创建, 删除事件, 以及数据更新事件. 如果该node存在, 则返回该node的状态信息, 否则返回null.</p>
</li>
<li><p>byte[] getData(String path, boolean watch, Stat stat)：获取指定节点上的数据<br>• watch— 参数用于指定是否监听path node的删除事件, 以及数据更新事件, 注意, 不监听path node的创建事件, 因为如果path node不存在, 该方法将抛出KeeperException.NoNodeException异常. • stat— 参数是个传出参数, getData方法会将path node的状态信息设置到该参数中.</p>
</li>
<li><p>Stat setData(final String path, byte data[], int version)：更新指定节点上存储的数据<br>• data— 为待更新的数据. • version— 参数指定要更新的数据的版本, 如果version和真实的版本不同, 更新操作将失败. 指定version为-1则忽略版本检查.</p>
</li>
<li><p>void delete(final String path, int version)：删除指定节点，可以指定删除指定版本</p>
</li>
</ol>
<h3 id="典型应用场景的浅析"><a href="#典型应用场景的浅析" class="headerlink" title="典型应用场景的浅析"></a>典型应用场景的浅析</h3><h4 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a><em>动态配置</em></h4><p>  由于zookeeper的节点上能够存储数据，如果客户端持续在节点上监听，也能实时地监测节点上数据的变化。借助这些特性可以利用zookeeper实现简单的远程动态配置管理。实现思路如下:</p>
<ul>
<li>指定zk服务端一个特定znode作为特定配置文件的存放点</li>
<li>配置文件可以以json序列化的形式存储，也就是每个配置文件对应一个json字符串存于相应znode上</li>
<li>客户端应用需要设置相应的监控回调watcher，一旦znode上存储的配置信息发生变更则将触发watcher,watcher中可以处理同步的逻辑。<br>代码大致如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">//获取应用内配置文件的路径</span><br><span class="line">public static String getFilePath() &#123;</span><br><span class="line">    return System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/resources/&quot; + FILENAME;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化zonode</span><br><span class="line">public static void initPath(String path) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zooKeeper = getZookeeperClient();</span><br><span class="line">        Stat stat = zooKeeper.exists(path, false);</span><br><span class="line">        if (stat == null) &#123;</span><br><span class="line">            zooKeeper.create(path, path.substring(1).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同步zknode上的配置信息到应用中</span><br><span class="line">public void handleUpdate() &#123;</span><br><span class="line">    FileWriter fileWriter = null;</span><br><span class="line">    ZooKeeper zk = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        zk = getZookeeperClient();</span><br><span class="line">        byte[] data = zk.getData(PROPERTIES_PATH, false, null);</span><br><span class="line">        String jsonStr = new String(data);</span><br><span class="line">        Map&lt;String, String&gt; map = JSON.parseObject(jsonStr, Map.class);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            sb.append(entry.getKey() + &quot;=&quot; + entry.getValue()).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        fileWriter = new FileWriter(getFilePath());</span><br><span class="line">        fileWriter.write(sb.toString());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (fileWriter != null) &#123;</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//借助zookeeper实现简单的动态配置</span><br><span class="line">public void testAutoSetPropertiesFile() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(PROPERTIES_PATH);</span><br><span class="line">    ZooKeeper zooKeeper = null;</span><br><span class="line">    final SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line">    try &#123;</span><br><span class="line">        //注册客户端时设置对配置节点的监听器</span><br><span class="line">        zooKeeper = getZookeeperClient(new Watcher() &#123;</span><br><span class="line">            public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">                if (watchedEvent.getType() != Event.EventType.None) &#123;</span><br><span class="line">                    LOGGER.info(&quot;配置文件发生了改变,开始同步到本地...&quot;);</span><br><span class="line">                    handleUpdate();  //监测到远程配置发生改变时进行本地同步</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.put(1);  //同步完成后注意解锁，以重新激活监听</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        LOGGER.error(e.getMessage());</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        File file = new File(getFilePath());</span><br><span class="line">        if (!file.exists()) &#123;  //本地应用第一次同步</span><br><span class="line">            handleUpdate();</span><br><span class="line">        &#125;</span><br><span class="line">        while (zooKeeper.exists(PROPERTIES_PATH, true) != null) &#123;   //通过exists方法持续激活监听器</span><br><span class="line">            queue.take();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，最重要的是在初始化zk时绑定了用于同步配置的Watcher()，然后调用exists(path,isWatch)时设isWatch为true即可使Watcher生效。需要注意的是Watcher一旦被调用一次后即失效，所以在这里循环调用exists(path,isWatch)使Watcher重新生效以达到持续监听的效果。使用了SynchronousQueue用于在远程配置无变化时就阻塞住线程，避免无限循环。</p>
<h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a><em>集群管理</em></h4><p>由于zk除了能够监听znode本身的状态外也能监控其子节点的状态，所以利用这一点可以很方便地构建出一个集群模型。利用一台主机持续对集群服务的公用注册节点下的子节点进行监控，这样在公用节点下注册的服务的变动都将被主机检测到。这里为了方便地检测到服务的上下线所以服务都已临时节点的方式注册，这样只要服务一断开则相应节点被删除就可被监控到，新服务的上线同理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">    //用于集群管理的watcher</span><br><span class="line">    public class ClusterWatcher implements Watcher &#123;</span><br><span class="line"></span><br><span class="line">        ZooKeeper zooKeeper;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; lock = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        public ClusterWatcher() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                zooKeeper = getZookeeperClient();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //用于在监听器触发时进行相关处理</span><br><span class="line">        public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">            if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.put(1);</span><br><span class="line">                    synchronized (zooKeeper) &#123;</span><br><span class="line">                        int chidren_actual = zooKeeper.getChildren(CLUSTER_PATH, false).size();</span><br><span class="line">                        //服务中心节点上储存有触发器触发前集群中子节点的数量</span><br><span class="line">                        int children_before = Integer.valueOf(new String(zooKeeper.getData(</span><br><span class="line">                                CLUSTER_PATH, false, null)));</span><br><span class="line">                        zooKeeper.setData(CLUSTER_PATH, String.valueOf(chidren_actual).getBytes(), -1);</span><br><span class="line">                        //通过对比触发器触发后服务中心下的实际子节点数量和触发前的子节点数量分辨是上线还是下线行为</span><br><span class="line">                        if (chidren_actual &gt; children_before) &#123;</span><br><span class="line">                            LOGGER.info(&quot;集群中有新服务上线...&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            LOGGER.info(&quot;集群中有服务下线...&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (KeeperException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void await() throws InterruptedException &#123;</span><br><span class="line">            lock.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//zookeeper模拟集群管理</span><br><span class="line">    public void simulateCluster() &#123;</span><br><span class="line"></span><br><span class="line">        initPath(CLUSTER_PATH);</span><br><span class="line">        LOGGER.info(&quot;模拟集群已初始化完毕，持续监听注册的客户端状态...&quot;);</span><br><span class="line">        final SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            ClusterWatcher clusterWatcher = new ClusterWatcher();</span><br><span class="line">            //初始化客户端连接时设置对中心服务节点的监听器</span><br><span class="line">            ZooKeeper zk = getZookeeperClient(clusterWatcher);</span><br><span class="line">            int serverCounts = zk.getChildren(CLUSTER_PATH, false).size();</span><br><span class="line">            //子服务每次上线时先在中心节点上存储一下当前的总的子服务的数量</span><br><span class="line">            zk.setData(CLUSTER_PATH, String.valueOf(serverCounts).getBytes(), -1);</span><br><span class="line">            //通过循环调用getChildren持续激活监听器</span><br><span class="line">            while (zk.getChildren(CLUSTER_PATH, true) != null) &#123; </span><br><span class="line">                clusterWatcher.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>关键点还是持续监控上，由于每次父节点下的子节点变动触发watcher后就会导致watcher失效。所以还是要在watcher每次被调用后立即重新让它生效，所以上面循环调用zk.getChildren(CLUSTER_PATH,true)。而且上面对服务的上下线的判断依赖于父节点始终存储着子节点变动前的子节点总数，子节点一旦变化则在watcher中将其与实时的子节点总数作对比。其实这里只是浅层次地实现了对集群中服务的在线状态实行监控，对集群的管理远不止这些，包括集群中leader的动态选择，这些大家可以自己去尝试，也比较简单。测试代码就不贴了，就是异步添加和删除多个临时节点的过程。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><em>分布式锁</em></h4><p>利用zk实现分布式锁也是依赖于znode，加锁解锁往往依赖于节点的创建删除。具体思路如下：</p>
<ul>
<li>建立一个父节点base_node</li>
<li>每当有应用要获取一个锁时则先到base_node下创建一个有序的临时节点</li>
<li>获取base_node 所有子节点集合并排序选出其中最小的节点，将其与2中创建的节点进行对比，判断最小的节点是不是2创建的节点</li>
<li>如果3判断最小的节点即是2创建的节点则获取锁成功，可以继续去处理加锁的业务；否则获取锁失败，可以阻塞住等待最小的节点离线，即其它应用解锁。</li>
<li>处理完业务后通过删除节点达到解锁的效果。 分析上面的思路可以发现，一旦一个刚创建的节点是最小的节点则加锁成功，这时如果外部有新的节点建立，由于是有序节点则新建立的节点肯定比当前存在的锁节点大，只能等待锁节点的删除才能成为最小的节点。<br>关键代码如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//zookeeper实现分布式锁</span><br><span class="line">public void simulateLock() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(LOCK_PATH);</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zk = getZookeeperClient();</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        String newNode = zk.create(LOCK_PATH + &quot;/&quot; + currentTime, String.valueOf(currentTime).getBytes(),</span><br><span class="line">                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);  //创建锁节点</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = zk.getChildren(LOCK_PATH, false);</span><br><span class="line">        String[] nodes = list.toArray(new String[list.size()]);</span><br><span class="line">        Arrays.sort(nodes);</span><br><span class="line">        if (newNode.equals(LOCK_PATH + &quot;/&quot; + nodes[0])) &#123;  //与zk中最小的锁节点比较，相同则获取锁成功</span><br><span class="line">            LOGGER.info(&quot;获取锁成功&quot;);</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            zk.close();    //由于创建的锁节点是临时节点，所以客户端退出即删除相应节点</span><br><span class="line">            lock_wait.put(1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LOGGER.info(&quot;获取锁失败，持续等待&quot;);</span><br><span class="line">            lock_wait.take();</span><br><span class="line">            zk.close();   //退出客户端以删除获取锁失败时创建的节点</span><br><span class="line">            simulateLock();  //尝试重新获取锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是lockwait是已经声明的一个静态的SynchronousQueue，一旦线程获取锁失败则通过lockwait.take()阻塞住，一旦线程释放锁完成则通过lock.wait.put()唤醒其它获取锁陷入阻塞的线程，之后这些线程可以重试锁。</p>
<h4 id="分布式阻塞队列"><a href="#分布式阻塞队列" class="headerlink" title="分布式阻塞队列"></a><em>分布式阻塞队列</em></h4><p>这里实现一个分布式的生产者-消费者模型的阻塞队列。原理比较简单，如下简述:</p>
<ul>
<li>建立一个队列的父节点，队列中的元素都将存储于其子节点中，入队则是新建子节点，出队则是删除子节点。</li>
<li>创建的子节点都是有序节点，这样保证队列中元素的有序性。</li>
<li>当入队时先检测当前父节点下的子节点数是否已经超出队列的最大容量，如果是则阻塞住等待元素的出队。出队时先检测父节点的子节点集是否为空，如果是则阻塞住等待元素的入队。<br>关键代码如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//用于分布式队列的监听器</span><br><span class="line">public class QueueWatcher implements Watcher &#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    public QueueWatcher() &#123;</span><br><span class="line">        latch = new CountDownLatch(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">        if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">            LOGGER.info(&quot;队列成员发生变更...&quot;);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void await() throws InterruptedException &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//zookeeper实现阻塞队列的生产者</span><br><span class="line">public void simulateProducer() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(QUEUE_PATH);</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zk = getZookeeperClient();</span><br><span class="line">        while (zk.exists(QUEUE_PATH, false) != null) &#123;</span><br><span class="line">            QueueWatcher watcher = new QueueWatcher();</span><br><span class="line">            //队列中元素超过上限时通过监听器中的锁阻塞</span><br><span class="line">            if (zk.getChildren(QUEUE_PATH, watcher).size() &gt;= queueSize) &#123;</span><br><span class="line">                LOGGER.info(&quot;由于队列已满，进入阻塞状态...&quot;);</span><br><span class="line">                watcher.await();</span><br><span class="line">            &#125;</span><br><span class="line">            //新元素入队</span><br><span class="line">            zk.create(QUEUE_PATH + &quot;/elem-&quot;, String.valueOf(System.currentTimeMillis()).getBytes(),</span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//zookeeper实现阻塞队列的消费者</span><br><span class="line">public void simulateCustomer() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(QUEUE_PATH);</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zk = getZookeeperClient();</span><br><span class="line">        while (zk.exists(QUEUE_PATH, false) != null) &#123;</span><br><span class="line">            QueueWatcher watcher = new QueueWatcher();</span><br><span class="line">            List&lt;String&gt; nodes = zk.getChildren(QUEUE_PATH, watcher);</span><br><span class="line">            //队列为空时阻塞</span><br><span class="line">            if (nodes.isEmpty()) &#123;</span><br><span class="line">                LOGGER.info(&quot;由于队列已空，消费者线程进入阻塞状态...&quot;);</span><br><span class="line">                watcher.await();</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //每次从队列中出队最小的元素</span><br><span class="line">                String[] products = nodes.toArray(new String[nodes.size()]);</span><br><span class="line">                Arrays.sort(products);</span><br><span class="line">                String path = QUEUE_PATH + &quot;/&quot; + products[0];</span><br><span class="line">                LOGGER.info(&quot;模拟处理队列&#123;&#125;中的&#123;&#125;元素对应的数据&quot;, QUEUE_PATH, path);</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">                zk.delete(path, -1);</span><br><span class="line">                LOGGER.info(&quot;处理完后从队列&#123;&#125;移除元素&#123;&#125;&quot;, QUEUE_PATH, path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        
    </entry>
    
  
  
</search>
