<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[浅析zookeeper的典型应用场景]]></title>
      <url>/2017/12/20/%E6%B5%85%E6%9E%90zookeeper%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<blockquote>
<p>平时写业务不免要用到一些分布式的中间件，例如dubbo、Kafka等，它们都有一个共同点，那就是都以zookeeper作为注册中心。由此可见在zookeeper在处理分布式应用中的地位。既然如此，有必要对zookeeper进行一番学习。本人初学zookeeper，刚好看了zookeeper的一些典型应用场景，所以就在此利用zookeeper的java api简单地实现一番。当然要声明的是在zk的正式应用中远比这些demo要做的复杂、考虑的全面的多。但是就像标题所写，这里是“浅析”，这些demo至少能够在凸显原理的基础上具有“浅析”之用。</p>
</blockquote>
<h3 id="基于java的zookeeper相关的api"><a href="#基于java的zookeeper相关的api" class="headerlink" title="基于java的zookeeper相关的api"></a>基于java的zookeeper相关的api</h3><p>  由于本文中所有场景的实现都要借助于Java语言，所以这里利用apache提供的官方包加以实现。首先需要作简要介绍:</p>
<ol>
<li><p>ZooKeeper(String connectString, int sessionTimeout, Watcher watcher) throws IOException ：创建zookeeper实例，对zookeeper的所有操作都将依赖于该实例。<br>• connectString— zookeeper server列表, 以逗号隔开. ZooKeeper对象初始化后, 将从server列表中选择一个server, 并尝试与其建立连接. 如果连接建立失败, 则会从列表的剩余项中选择一个server, 并再次尝试建立连接. • sessionTimeout— 指定连接的超时时间. • watcher— 事件回调接口.</p>
</li>
<li><p>String create(String path, byte[] data, List acl, CreateMode createMode) : 创建节点<br>• path— znode的路径. • data— 与znode关联的数据. • acl— 指定权限信息, 如果不想指定权限, 可以传入Ids.OPENACLUNSAFE. • createMode— 指定znode类型. CreateMode是一个枚举类, 从中选择一个成员传入即可. 常见有以下几种模式 : PERSISTENT(创建持久化节点) PERSISTENTSEQUENTIAL(创建有序的持久化节点) EPHEMERAL(创建临时节点) EPHEMERALSEQUENTIAL(创建有序的临时节点)。所谓临时节点是指创建该节点的客户端一旦失去连接，则节点自动删除</p>
</li>
<li><p>List getChildren(String path, boolean watch)：获取指定节点的所有子节点<br>• watch— 参数用于指定是否监听path node的子node的增加和删除事件, 以及path node本身的删除事件.</p>
</li>
<li><p>Stat exists(String path, boolean watch)：检测指定节点的状态，可以绑定监控事件<br>• watch参数用于指定是否监听path node的创建, 删除事件, 以及数据更新事件. 如果该node存在, 则返回该node的状态信息, 否则返回null.</p>
</li>
<li><p>byte[] getData(String path, boolean watch, Stat stat)：获取指定节点上的数据<br>• watch— 参数用于指定是否监听path node的删除事件, 以及数据更新事件, 注意, 不监听path node的创建事件, 因为如果path node不存在, 该方法将抛出KeeperException.NoNodeException异常. • stat— 参数是个传出参数, getData方法会将path node的状态信息设置到该参数中.</p>
</li>
<li><p>Stat setData(final String path, byte data[], int version)：更新指定节点上存储的数据<br>• data— 为待更新的数据. • version— 参数指定要更新的数据的版本, 如果version和真实的版本不同, 更新操作将失败. 指定version为-1则忽略版本检查.</p>
</li>
<li><p>void delete(final String path, int version)：删除指定节点，可以指定删除指定版本</p>
</li>
</ol>
<h3 id="典型应用场景的浅析"><a href="#典型应用场景的浅析" class="headerlink" title="典型应用场景的浅析"></a>典型应用场景的浅析</h3><h4 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h4><p>  由于zookeeper的节点上能够存储数据，如果客户端持续在节点上监听，也能实时地监测节点上数据的变化。借助这些特性可以利用zookeeper实现简单的远程动态配置管理。实现思路如下:</p>
<ul>
<li>指定zk服务端一个特定znode作为特定配置文件的存放点</li>
<li>配置文件可以以json序列化的形式存储，也就是每个配置文件对应一个json字符串存于相应znode上</li>
<li>客户端应用需要设置相应的监控回调watcher，一旦znode上存储的配置信息发生变更则将触发watcher,watcher中可以处理同步的逻辑。<br>代码大致如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">//获取应用内配置文件的路径</span><br><span class="line">    public static String getFilePath() &#123;</span><br><span class="line">        return System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/resources/&quot; + FILENAME;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void initPath(String path) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ZooKeeper zooKeeper = getZookeeperClient();</span><br><span class="line">            Stat stat = zooKeeper.exists(path, false);</span><br><span class="line">            if (stat == null) &#123;</span><br><span class="line">                zooKeeper.create(path, path.substring(1).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理zookeeper上配置文件对应节点的更改</span><br><span class="line">    public void handleUpdate() &#123;</span><br><span class="line">        FileWriter fileWriter = null;</span><br><span class="line">        ZooKeeper zk = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            zk = getZookeeperClient();</span><br><span class="line">            byte[] data = zk.getData(PROPERTIES_PATH, false, null);</span><br><span class="line">            String jsonStr = new String(data);</span><br><span class="line">            Map&lt;String, String&gt; map = JSON.parseObject(jsonStr, Map.class);</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                sb.append(entry.getKey() + &quot;=&quot; + entry.getValue()).append(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            fileWriter = new FileWriter(getFilePath());</span><br><span class="line">            fileWriter.write(sb.toString());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fileWriter != null) &#123;</span><br><span class="line">                    fileWriter.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                LOGGER.error(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //借助zookeeper实现简单的动态配置</span><br><span class="line">    public void testAutoSetPropertiesFile() &#123;</span><br><span class="line"></span><br><span class="line">        initPath(PROPERTIES_PATH);</span><br><span class="line">        ZooKeeper zooKeeper = null;</span><br><span class="line">        final SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            zooKeeper = getZookeeperClient(new Watcher() &#123;</span><br><span class="line">                public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">                    if (watchedEvent.getType() != Event.EventType.None) &#123;</span><br><span class="line">                        LOGGER.info(&quot;配置文件发生了改变,开始同步到本地...&quot;);</span><br><span class="line">                        handleUpdate();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            queue.put(1);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            LOGGER.error(e.getMessage());</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            File file = new File(getFilePath());</span><br><span class="line">            if (!file.exists()) &#123;</span><br><span class="line">                handleUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">            while (zooKeeper.exists(PROPERTIES_PATH, true) != null) &#123;   //此处会持续监听远程配置文件的改动</span><br><span class="line">                queue.take();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，最重要的是在初始化zk时绑定了用于同步配置的Watcher()，然后调用exists(path,isWatch)时设isWatch为true即可使Watcher生效。需要注意的是Watcher一旦被调用一次后即失效，所以在这里循环调用exists(path,isWatch)使Watcher重新生效以达到持续监听的效果。使用了SynchronousQueue用于在远程配置无变化时就阻塞住线程，避免无限循环。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
