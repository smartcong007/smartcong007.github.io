<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[浅析zookeeper的典型应用场景]]></title>
      <url>/2017/12/20/%E6%B5%85%E6%9E%90zookeeper%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<blockquote>
<p>平时写业务不免要用到一些分布式的中间件，例如dubbo、Kafka等，它们都有一个共同点，那就是都以zookeeper作为注册中心。由此可见在zookeeper在处理分布式应用中的地位。既然如此，有必要对zookeeper进行一番学习。本人初学zookeeper，刚好看了zookeeper的一些典型应用场景，所以就在此利用zookeeper的java api简单地实现一番。当然要声明的是在zk的正式应用中远比这些demo要做的复杂、考虑的全面的多。但是就像标题所写，这里是“浅析”，这些demo至少能够在凸显原理的基础上具有“浅析”之用。</p>
</blockquote>
<h3 id="基于java的zookeeper相关的api"><a href="#基于java的zookeeper相关的api" class="headerlink" title="基于java的zookeeper相关的api"></a>基于java的zookeeper相关的api</h3><p>  由于本文中所有场景的实现都要借助于Java语言，所以这里利用apache提供的官方包加以实现。首先需要作简要介绍:</p>
<ol>
<li><p>ZooKeeper(String connectString, int sessionTimeout, Watcher watcher) throws IOException ：创建zookeeper实例，对zookeeper的所有操作都将依赖于该实例。<br>• connectString— zookeeper server列表, 以逗号隔开. ZooKeeper对象初始化后, 将从server列表中选择一个server, 并尝试与其建立连接. 如果连接建立失败, 则会从列表的剩余项中选择一个server, 并再次尝试建立连接. • sessionTimeout— 指定连接的超时时间. • watcher— 事件回调接口.</p>
</li>
<li><p>String create(String path, byte[] data, List acl, CreateMode createMode) : 创建节点<br>• path— znode的路径. • data— 与znode关联的数据. • acl— 指定权限信息, 如果不想指定权限, 可以传入Ids.OPENACLUNSAFE. • createMode— 指定znode类型. CreateMode是一个枚举类, 从中选择一个成员传入即可. 常见有以下几种模式 : PERSISTENT(创建持久化节点) PERSISTENTSEQUENTIAL(创建有序的持久化节点) EPHEMERAL(创建临时节点) EPHEMERALSEQUENTIAL(创建有序的临时节点)。所谓临时节点是指创建该节点的客户端一旦失去连接，则节点自动删除</p>
</li>
<li><p>List getChildren(String path, boolean watch)：获取指定节点的所有子节点<br>• watch— 参数用于指定是否监听path node的子node的增加和删除事件, 以及path node本身的删除事件.</p>
</li>
<li><p>Stat exists(String path, boolean watch)：检测指定节点的状态，可以绑定监控事件<br>• watch参数用于指定是否监听path node的创建, 删除事件, 以及数据更新事件. 如果该node存在, 则返回该node的状态信息, 否则返回null.</p>
</li>
<li><p>byte[] getData(String path, boolean watch, Stat stat)：获取指定节点上的数据<br>• watch— 参数用于指定是否监听path node的删除事件, 以及数据更新事件, 注意, 不监听path node的创建事件, 因为如果path node不存在, 该方法将抛出KeeperException.NoNodeException异常. • stat— 参数是个传出参数, getData方法会将path node的状态信息设置到该参数中.</p>
</li>
<li><p>Stat setData(final String path, byte data[], int version)：更新指定节点上存储的数据<br>• data— 为待更新的数据. • version— 参数指定要更新的数据的版本, 如果version和真实的版本不同, 更新操作将失败. 指定version为-1则忽略版本检查.</p>
</li>
<li><p>void delete(final String path, int version)：删除指定节点，可以指定删除指定版本</p>
</li>
</ol>
<h3 id="典型应用场景的浅析"><a href="#典型应用场景的浅析" class="headerlink" title="典型应用场景的浅析"></a>典型应用场景的浅析</h3><h4 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a><em>动态配置</em></h4><p>  由于zookeeper的节点上能够存储数据，如果客户端持续在节点上监听，也能实时地监测节点上数据的变化。借助这些特性可以利用zookeeper实现简单的远程动态配置管理。实现思路如下:</p>
<ul>
<li>指定zk服务端一个特定znode作为特定配置文件的存放点</li>
<li>配置文件可以以json序列化的形式存储，也就是每个配置文件对应一个json字符串存于相应znode上</li>
<li>客户端应用需要设置相应的监控回调watcher，一旦znode上存储的配置信息发生变更则将触发watcher,watcher中可以处理同步的逻辑。<br>代码大致如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">//获取应用内配置文件的路径</span><br><span class="line">public static String getFilePath() &#123;</span><br><span class="line">    return System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/resources/&quot; + FILENAME;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化zonode</span><br><span class="line">public static void initPath(String path) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zooKeeper = getZookeeperClient();</span><br><span class="line">        Stat stat = zooKeeper.exists(path, false);</span><br><span class="line">        if (stat == null) &#123;</span><br><span class="line">            zooKeeper.create(path, path.substring(1).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同步zknode上的配置信息到应用中</span><br><span class="line">public void handleUpdate() &#123;</span><br><span class="line">    FileWriter fileWriter = null;</span><br><span class="line">    ZooKeeper zk = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        zk = getZookeeperClient();</span><br><span class="line">        byte[] data = zk.getData(PROPERTIES_PATH, false, null);</span><br><span class="line">        String jsonStr = new String(data);</span><br><span class="line">        Map&lt;String, String&gt; map = JSON.parseObject(jsonStr, Map.class);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            sb.append(entry.getKey() + &quot;=&quot; + entry.getValue()).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        fileWriter = new FileWriter(getFilePath());</span><br><span class="line">        fileWriter.write(sb.toString());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (fileWriter != null) &#123;</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//借助zookeeper实现简单的动态配置</span><br><span class="line">public void testAutoSetPropertiesFile() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(PROPERTIES_PATH);</span><br><span class="line">    ZooKeeper zooKeeper = null;</span><br><span class="line">    final SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line">    try &#123;</span><br><span class="line">        //注册客户端时设置对配置节点的监听器</span><br><span class="line">        zooKeeper = getZookeeperClient(new Watcher() &#123;</span><br><span class="line">            public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">                if (watchedEvent.getType() != Event.EventType.None) &#123;</span><br><span class="line">                    LOGGER.info(&quot;配置文件发生了改变,开始同步到本地...&quot;);</span><br><span class="line">                    handleUpdate();  //监测到远程配置发生改变时进行本地同步</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.put(1);  //同步完成后注意解锁，以重新激活监听</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        LOGGER.error(e.getMessage());</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        File file = new File(getFilePath());</span><br><span class="line">        if (!file.exists()) &#123;  //本地应用第一次同步</span><br><span class="line">            handleUpdate();</span><br><span class="line">        &#125;</span><br><span class="line">        while (zooKeeper.exists(PROPERTIES_PATH, true) != null) &#123;   //通过exists方法持续激活监听器</span><br><span class="line">            queue.take();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，最重要的是在初始化zk时绑定了用于同步配置的Watcher()，然后调用exists(path,isWatch)时设isWatch为true即可使Watcher生效。需要注意的是Watcher一旦被调用一次后即失效，所以在这里循环调用exists(path,isWatch)使Watcher重新生效以达到持续监听的效果。使用了SynchronousQueue用于在远程配置无变化时就阻塞住线程，避免无限循环。</p>
<h4 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a><em>集群管理</em></h4><p>由于zk除了能够监听znode本身的状态外也能监控其子节点的状态，所以利用这一点可以很方便地构建出一个集群模型。利用一台主机持续对集群服务的公用注册节点下的子节点进行监控，这样在公用节点下注册的服务的变动都将被主机检测到。这里为了方便地检测到服务的上下线所以服务都已临时节点的方式注册，这样只要服务一断开则相应节点被删除就可被监控到，新服务的上线同理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">    //用于集群管理的watcher</span><br><span class="line">    public class ClusterWatcher implements Watcher &#123;</span><br><span class="line"></span><br><span class="line">        ZooKeeper zooKeeper;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; lock = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        public ClusterWatcher() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                zooKeeper = getZookeeperClient();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //用于在监听器触发时进行相关处理</span><br><span class="line">        public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">            if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.put(1);</span><br><span class="line">                    synchronized (zooKeeper) &#123;</span><br><span class="line">                        int chidren_actual = zooKeeper.getChildren(CLUSTER_PATH, false).size();</span><br><span class="line">                        //服务中心节点上储存有触发器触发前集群中子节点的数量</span><br><span class="line">                        int children_before = Integer.valueOf(new String(zooKeeper.getData(</span><br><span class="line">                                CLUSTER_PATH, false, null)));</span><br><span class="line">                        zooKeeper.setData(CLUSTER_PATH, String.valueOf(chidren_actual).getBytes(), -1);</span><br><span class="line">                        //通过对比触发器触发后服务中心下的实际子节点数量和触发前的子节点数量分辨是上线还是下线行为</span><br><span class="line">                        if (chidren_actual &gt; children_before) &#123;</span><br><span class="line">                            LOGGER.info(&quot;集群中有新服务上线...&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            LOGGER.info(&quot;集群中有服务下线...&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (KeeperException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void await() throws InterruptedException &#123;</span><br><span class="line">            lock.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//zookeeper模拟集群管理</span><br><span class="line">    public void simulateCluster() &#123;</span><br><span class="line"></span><br><span class="line">        initPath(CLUSTER_PATH);</span><br><span class="line">        LOGGER.info(&quot;模拟集群已初始化完毕，持续监听注册的客户端状态...&quot;);</span><br><span class="line">        final SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            ClusterWatcher clusterWatcher = new ClusterWatcher();</span><br><span class="line">            //初始化客户端连接时设置对中心服务节点的监听器</span><br><span class="line">            ZooKeeper zk = getZookeeperClient(clusterWatcher);</span><br><span class="line">            int serverCounts = zk.getChildren(CLUSTER_PATH, false).size();</span><br><span class="line">            //子服务每次上线时先在中心节点上存储一下当前的总的子服务的数量</span><br><span class="line">            zk.setData(CLUSTER_PATH, String.valueOf(serverCounts).getBytes(), -1);</span><br><span class="line">            //通过循环调用getChildren持续激活监听器</span><br><span class="line">            while (zk.getChildren(CLUSTER_PATH, true) != null) &#123; </span><br><span class="line">                clusterWatcher.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>关键点还是持续监控上，由于每次父节点下的子节点变动触发watcher后就会导致watcher失效。所以还是要在watcher每次被调用后立即重新让它生效，所以上面循环调用zk.getChildren(CLUSTER_PATH,true)。而且上面对服务的上下线的判断依赖于父节点始终存储着子节点变动前的子节点总数，子节点一旦变化则在watcher中将其与实时的子节点总数作对比。其实这里只是浅层次地实现了对集群中服务的在线状态实行监控，对集群的管理远不止这些，包括集群中leader的动态选择，这些大家可以自己去尝试，也比较简单。测试代码就不贴了，就是异步添加和删除多个临时节点的过程。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><em>分布式锁</em></h4><p>利用zk实现分布式锁也是依赖于znode，加锁解锁往往依赖于节点的创建删除。具体思路如下：</p>
<ul>
<li>建立一个父节点base_node</li>
<li>每当有应用要获取一个锁时则先到base_node下创建一个有序的临时节点</li>
<li>获取base_node 所有子节点集合并排序选出其中最小的节点，将其与2中创建的节点进行对比，判断最小的节点是不是2创建的节点</li>
<li>如果3判断最小的节点即是2创建的节点则获取锁成功，可以继续去处理加锁的业务；否则获取锁失败，可以阻塞住等待最小的节点离线，即其它应用解锁。</li>
<li>处理完业务后通过删除节点达到解锁的效果。 分析上面的思路可以发现，一旦一个刚创建的节点是最小的节点则加锁成功，这时如果外部有新的节点建立，由于是有序节点则新建立的节点肯定比当前存在的锁节点大，只能等待锁节点的删除才能成为最小的节点。<br>关键代码如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//zookeeper实现分布式锁</span><br><span class="line">public void simulateLock() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(LOCK_PATH);</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zk = getZookeeperClient();</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        String newNode = zk.create(LOCK_PATH + &quot;/&quot; + currentTime, String.valueOf(currentTime).getBytes(),</span><br><span class="line">                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);  //创建锁节点</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = zk.getChildren(LOCK_PATH, false);</span><br><span class="line">        String[] nodes = list.toArray(new String[list.size()]);</span><br><span class="line">        Arrays.sort(nodes);</span><br><span class="line">        if (newNode.equals(LOCK_PATH + &quot;/&quot; + nodes[0])) &#123;  //与zk中最小的锁节点比较，相同则获取锁成功</span><br><span class="line">            LOGGER.info(&quot;获取锁成功&quot;);</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            zk.close();    //由于创建的锁节点是临时节点，所以客户端退出即删除相应节点</span><br><span class="line">            lock_wait.put(1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LOGGER.info(&quot;获取锁失败，持续等待&quot;);</span><br><span class="line">            lock_wait.take();</span><br><span class="line">            zk.close();   //退出客户端以删除获取锁失败时创建的节点</span><br><span class="line">            simulateLock();  //尝试重新获取锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是lockwait是已经声明的一个静态的SynchronousQueue，一旦线程获取锁失败则通过lockwait.take()阻塞住，一旦线程释放锁完成则通过lock.wait.put()唤醒其它获取锁陷入阻塞的线程，之后这些线程可以重试锁。</p>
<h4 id="分布式阻塞队列"><a href="#分布式阻塞队列" class="headerlink" title="分布式阻塞队列"></a><em>分布式阻塞队列</em></h4><p>这里实现一个分布式的生产者-消费者模型的阻塞队列。原理比较简单，如下简述:</p>
<ul>
<li>建立一个队列的父节点，队列中的元素都将存储于其子节点中，入队则是新建子节点，出队则是删除子节点。</li>
<li>创建的子节点都是有序节点，这样保证队列中元素的有序性。</li>
<li>当入队时先检测当前父节点下的子节点数是否已经超出队列的最大容量，如果是则阻塞住等待元素的出队。出队时先检测父节点的子节点集是否为空，如果是则阻塞住等待元素的入队。<br>关键代码如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//用于分布式队列的监听器</span><br><span class="line">public class QueueWatcher implements Watcher &#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    public QueueWatcher() &#123;</span><br><span class="line">        latch = new CountDownLatch(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">        if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">            LOGGER.info(&quot;队列成员发生变更...&quot;);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void await() throws InterruptedException &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//zookeeper实现阻塞队列的生产者</span><br><span class="line">public void simulateProducer() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(QUEUE_PATH);</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zk = getZookeeperClient();</span><br><span class="line">        while (zk.exists(QUEUE_PATH, false) != null) &#123;</span><br><span class="line">            QueueWatcher watcher = new QueueWatcher();</span><br><span class="line">            //队列中元素超过上限时通过监听器中的锁阻塞</span><br><span class="line">            if (zk.getChildren(QUEUE_PATH, watcher).size() &gt;= queueSize) &#123;</span><br><span class="line">                LOGGER.info(&quot;由于队列已满，进入阻塞状态...&quot;);</span><br><span class="line">                watcher.await();</span><br><span class="line">            &#125;</span><br><span class="line">            //新元素入队</span><br><span class="line">            zk.create(QUEUE_PATH + &quot;/elem-&quot;, String.valueOf(System.currentTimeMillis()).getBytes(),</span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//zookeeper实现阻塞队列的消费者</span><br><span class="line">public void simulateCustomer() &#123;</span><br><span class="line"></span><br><span class="line">    initPath(QUEUE_PATH);</span><br><span class="line">    try &#123;</span><br><span class="line">        ZooKeeper zk = getZookeeperClient();</span><br><span class="line">        while (zk.exists(QUEUE_PATH, false) != null) &#123;</span><br><span class="line">            QueueWatcher watcher = new QueueWatcher();</span><br><span class="line">            List&lt;String&gt; nodes = zk.getChildren(QUEUE_PATH, watcher);</span><br><span class="line">            //队列为空时阻塞</span><br><span class="line">            if (nodes.isEmpty()) &#123;</span><br><span class="line">                LOGGER.info(&quot;由于队列已空，消费者线程进入阻塞状态...&quot;);</span><br><span class="line">                watcher.await();</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //每次从队列中出队最小的元素</span><br><span class="line">                String[] products = nodes.toArray(new String[nodes.size()]);</span><br><span class="line">                Arrays.sort(products);</span><br><span class="line">                String path = QUEUE_PATH + &quot;/&quot; + products[0];</span><br><span class="line">                LOGGER.info(&quot;模拟处理队列&#123;&#125;中的&#123;&#125;元素对应的数据&quot;, QUEUE_PATH, path);</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">                zk.delete(path, -1);</span><br><span class="line">                LOGGER.info(&quot;处理完后从队列&#123;&#125;移除元素&#123;&#125;&quot;, QUEUE_PATH, path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        
    </entry>
    
  
  
</search>
